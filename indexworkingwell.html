<!doctype html>
<html lang="he" dir="rtl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>מחשבון GSD (Ground Sample Distance)</title>
  <style>
    :root{
      --bg:#0b1020; --card:#121a33; --muted:#a8b3d6; --text:#eef2ff;
      --line:rgba(255,255,255,.12);
      --good:#33d17a; --warn:#ffb020; --bad:#ff4d4d;
      --radius:16px;
    }
    *{ box-sizing:border-box; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    body{ margin:0; background:linear-gradient(180deg,#070a14,#0b1020 45%,#070a14); color:var(--text); }
    header{
      position:sticky; top:0; z-index:50; backdrop-filter: blur(10px);
      background:rgba(11,16,32,.65); border-bottom:1px solid var(--line);
    }
    .wrap{ max-width:1100px; margin:0 auto; padding:16px; }
    h1{ margin:0; font-size:20px; letter-spacing:.2px; }
    .sub{ margin-top:6px; color:var(--muted); font-size:13px; }
    .grid{
      display:grid; gap:12px; margin-top:14px;
      grid-template-columns: 1.1fr .9fr;
    }
    @media (max-width: 980px){ .grid{ grid-template-columns:1fr; } }
    .card{
      background:rgba(18,26,51,.72);
      border:1px solid var(--line);
      border-radius:var(--radius);
      box-shadow: 0 10px 25px rgba(0,0,0,.25);
      overflow:hidden;
    }
    .card .hd{
      padding:14px 14px 10px;
      border-bottom:1px solid var(--line);
      display:flex; justify-content:space-between; align-items:flex-start; gap:10px;
    }
    .card .hd .t{ font-weight:700; }
    .card .bd{ padding:14px; }
    .row{ display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
    @media (max-width: 520px){ .row{ grid-template-columns:1fr; } }
    label{ display:block; font-size:12px; color:var(--muted); margin-bottom:6px; }
    input, select{
      width:100%; padding:10px 10px;
      border-radius:12px;
      border:1px solid var(--line);
      background:rgba(255,255,255,.06);
      color:var(--text);
      outline:none;
    }
    input:focus, select:focus{ border-color: rgba(168,179,214,.45); box-shadow: 0 0 0 3px rgba(168,179,214,.15); }
    .seg{
      display:flex; gap:8px; flex-wrap:wrap;
      background:rgba(255,255,255,.05);
      border:1px solid var(--line);
      padding:8px; border-radius:14px;
    }
    .seg button{
      flex:1; min-width:160px;
      border:1px solid transparent;
      border-radius:12px;
      padding:9px 10px;
      background:rgba(255,255,255,.06);
      color:var(--text);
      cursor:pointer;
    }
    .seg button.active{
      background:rgba(51,209,122,.14);
      border-color: rgba(51,209,122,.35);
    }
    .note{
      margin-top:10px; color:var(--muted); font-size:12px; line-height:1.45;
    }
    table{
      width:100%; border-collapse: collapse; overflow:hidden;
      border-radius:12px; border:1px solid var(--line);
    }
    th, td{
      padding:10px 10px;
      border-bottom:1px solid var(--line);
      font-size:13px;
      vertical-align:top;
    }
    th{ text-align:right; color:var(--muted); background:rgba(255,255,255,.04); font-weight:650; }
    tr:last-child td{ border-bottom:none; }
    .badge{
      display:inline-block; padding:2px 8px; border-radius:999px;
      border:1px solid var(--line); font-size:12px; color:var(--muted);
      background:rgba(255,255,255,.04);
      margin-inline-start:8px;
    }
    .ok{ color: var(--good); }
    .warn{ color: var(--warn); }
    .bad{ color: var(--bad); }
    .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }
    .svgBox{
      border:1px solid var(--line);
      background:rgba(255,255,255,.03);
      border-radius:12px;
      overflow:hidden;
    }
    .foot{
      margin-top:12px; padding-top:10px; border-top:1px solid var(--line);
      color:var(--muted); font-size:12px; line-height:1.45;
    }
    .small{ font-size:12px; color:var(--muted); }

    /* Johnson table highlighting */
    .j-pass td{
      background: rgba(51,209,122,.10);
    }
    .j-fail td{
      background: rgba(255,77,77,.10);
    }
    .pill{
      display:inline-block;
      padding:2px 8px;
      border-radius:999px;
      border:1px solid var(--line);
      font-size:12px;
      background:rgba(255,255,255,.04);
    }
    .pill.pass{ color: var(--good); border-color: rgba(51,209,122,.35); background:rgba(51,209,122,.10); }
    .pill.fail{ color: var(--bad); border-color: rgba(255,77,77,.35); background:rgba(255,77,77,.10); }
    details{ border:1px solid var(--line); border-radius:12px; padding:10px 12px; background:rgba(255,255,255,.03); }
    summary{ cursor:pointer; color:var(--text); font-weight:650; }
    .hint{ color:var(--muted); font-size:12px; margin-top:6px; line-height:1.45; }
    .mini3{ display:grid; grid-template-columns: 1fr 1fr 1fr; gap:10px; }
    @media (max-width: 860px){ .mini3{ grid-template-columns:1fr; } }
    .mini4{ display:grid; grid-template-columns: 1fr 1fr 1fr 1fr; gap:10px; }
    @media (max-width: 980px){ .mini4{ grid-template-columns:1fr; } }
  </style>
</head>
<body>
<header>
  <div class="wrap">
    <h1>מחשבון GSD (Ground Sample Distance)</h1>
    <div class="sub">
      מודל פין-הול, קרקע מישורית. זווית הסתכלות: <span class="mono">0° = אופק</span>, <span class="mono">-90° = למטה</span>.
      <span class="badge">GitHub Pages Ready</span>
    </div>
  </div>
</header>

<main class="wrap">
  <div class="grid">
    <!-- Inputs -->
    <section class="card">
      <div class="hd">
        <div class="t">קלטים</div>
        <div class="small" id="statusLine">טוען…</div>
      </div>
      <div class="bd">
        <div class="row">
          <div>
            <label>רזולוציה אופקית (px)</label>
            <input id="pxW" type="number" min="1" step="1" value="3840" />
          </div>
          <div>
            <label>רזולוציה אנכית (px)</label>
            <input id="pxH" type="number" min="1" step="1" value="2160" />
          </div>
        </div>

        <div class="row" style="margin-top:10px;">
          <div>
            <label>גובה מעל הקרקע (m)</label>
            <input id="altM" type="number" min="0.1" step="0.1" value="120" />
          </div>
          <div>
            <label>זווית הסתכלות (deg) — 0 אופק, -90 למטה</label>
            <input id="lookDeg" type="number" min="-90" max="0" step="0.1" value="-90" />
          </div>
        </div>

        <div style="margin-top:12px;">
          <label>שיטת הזנת שדה ראייה / אופטיקה</label>
          <div class="seg">
            <button id="btnFov" class="active" type="button">HFOV/VFOV (מעלות)</button>
            <button id="btnFocal" type="button">חיישן + אורך מוקד (mm)</button>
          </div>
        </div>

        <!-- FOV mode -->
        <div id="modeFov" style="margin-top:12px;">
          <div class="row">
            <div>
              <label>HFOV (מעלות)</label>
              <input id="hfovDeg" type="number" min="1" max="179" step="0.1" value="60" />
            </div>
            <div>
              <label>VFOV (מעלות)</label>
              <input id="vfovDeg" type="number" min="1" max="179" step="0.1" value="35" />
            </div>
          </div>
          <div class="note">
            אם יש לך רק HFOV, תוכל להעריך VFOV לפי יחס הרזולוציה (או להזין ידנית).
          </div>
        </div>

        <!-- Focal mode -->
        <div id="modeFocal" style="margin-top:12px; display:none;">
          <div class="row">
            <div>
              <label>רוחב חיישן (mm)</label>
              <input id="sensorWmm" type="number" min="0.1" step="0.01" value="6.4" />
            </div>
            <div>
              <label>גובה חיישן (mm)</label>
              <input id="sensorHmm" type="number" min="0.1" step="0.01" value="4.8" />
            </div>
          </div>
          <div class="row" style="margin-top:10px;">
            <div>
              <label>אורך מוקד (mm)</label>
              <input id="focalMm" type="number" min="0.1" step="0.01" value="8.0" />
            </div>
            <div>
              <label>הערה</label>
              <input disabled value="HFOV/VFOV יחושבו אוטומטית מהנתונים" />
            </div>
          </div>
          <div class="note">
            חישוב: <span class="mono">FOV = 2·atan(sensor/(2·focal))</span>.
          </div>
        </div>

        <div class="foot">
          הנחות: קרקע מישורית, ציר המצלמה ללא Roll, “Forward” הוא כיוון התצפית. בזוויות אלכסוניות ה-GSD אינו אחיד, לכן מוצג גם טווח (קרוב/רחוק).
        </div>
      </div>
    </section>

    <!-- Outputs -->
    <section class="card">
      <div class="hd">
        <div class="t">תוצאות</div>
        <div class="small" id="fovEcho">—</div>
      </div>
      <div class="bd">
        <table>
          <tbody>
            <tr>
              <th>Slant Range (לציר המרכזי)</th>
              <td><span id="slant" class="mono">—</span> <span class="small">m</span></td>
            </tr>
            <tr>
              <th>Forward distance (פגיעה של הציר המרכזי)</th>
              <td><span id="centerX" class="mono">—</span> <span class="small">m</span></td>
            </tr>
            <tr>
              <th>Footprint Area (פוליגון 4 פינות)</th>
              <td><span id="area" class="mono">—</span> <span class="small">m²</span></td>
            </tr>
            <tr>
              <th>Footprint Width (שמאל-ימין)</th>
              <td><span id="wNearFar" class="mono">—</span> <span class="small">m (קרוב→רחוק)</span></td>
            </tr>
            <tr>
              <th>Footprint Depth (קדימה)</th>
              <td><span id="depth" class="mono">—</span> <span class="small">m</span></td>
            </tr>
            <tr>
              <th>GSD X (רוחבי)</th>
              <td>
                <div><span id="gsdXavg" class="mono">—</span> <span class="small">m/px</span> (<span id="gsdXavgCm" class="mono">—</span> <span class="small">cm/px</span>)</div>
                <div class="small">טווח: <span id="gsdXminmax" class="mono">—</span> m/px (רחוק→קרוב)</div>
              </td>
            </tr>
            <tr>
              <th>GSD Y (אורכי)</th>
              <td>
                <div><span id="gsdYavg" class="mono">—</span> <span class="small">m/px</span> (<span id="gsdYavgCm" class="mono">—</span> <span class="small">cm/px</span>)</div>
                <div class="small">בקירוב (הקרנה אלכסונית גורמת לשונות לאורך הפריים)</div>
              </td>
            </tr>
          </tbody>
        </table>

        <div style="height:12px;"></div>
        <div class="svgBox">
          <svg id="viz" viewBox="0 0 920 420" width="100%" height="auto" aria-label="תרשים גיאומטריה">
            <!-- Filled by JS -->
          </svg>
        </div>

        <div class="note">
          לצרכי חישוב: נקודות הפוליגון מתקבלות מחיתוך הקרניים (פינות הפריים) עם מישור הקרקע.
          ה-GSD הרוחבי מחושב לכל אחת מהשורות (העליונה=רחוק, התחתונה=קרוב) לפי רוחב בשטח חלקי פיקסלים.
        </div>
      </div>
    </section>
  </div>

  <!-- Johnson / DRI section -->
  <section class="card" style="margin-top:12px;">
    <div class="hd">
      <div class="t">קריטריון ג׳ונסון (DRI) — התאמה לפי GSD</div>
      <div class="small" id="johnsonLine">—</div>
    </div>
    <div class="bd">

      <div class="row">
        <div>
          <label>בחר איזה GSD להזין לטבלת ג׳ונסון</label>
          <select id="gsdSource">
            <option value="x_avg" selected>GSD X avg (מומלץ כברירת מחדל)</option>
            <option value="x_far">GSD X far (שורה עליונה=רחוק)</option>
            <option value="x_near">GSD X near (שורה תחתונה=קרוב)</option>
            <option value="y_avg">GSD Y avg (בקירוב)</option>
          </select>
          <div class="hint">הטבלה מניחה יחס ליניארי: Rmax = Rnow · (GSDmax/GSDnow). כאן Rnow הוא Slant Range של ציר המרכזי.</div>
        </div>

        <div>
          <label>סף הצלחה</label>
          <select id="probMode">
            <option value="50" selected>50%</option>
            <option value="90">90%</option>
          </select>
          <div class="hint">ב-90% משתמשים במקדם N90 = N50 · K (ניתן לשינוי בהגדרות למטה).</div>
        </div>
      </div>

      <div style="height:12px;"></div>

      <table aria-label="Johnson DRI table">
        <thead>
          <tr>
            <th style="width:16%;">טווח מקסימלי (m)</th>
            <th style="width:10%;">סטטוס</th>
            <th style="width:14%;">GSDmax (m/px)</th>
            <th style="width:14%;">GSD בפועל (m/px)</th>
            <th style="width:10%;">N נדרש</th>
            <th style="width:10%;">הסתברות</th>
            <th style="width:12%;">משימה</th>
            <th style="width:10%;">מטרה</th>
            <th style="width:14%;">CD (m)</th>
          </tr>
        </thead>
        <tbody id="johnsonBody">
          <!-- Filled by JS -->
        </tbody>
      </table>

      <div style="height:12px;"></div>

      <details>
        <summary>הגדרות ג׳ונסון — עריכה</summary>

        <div class="hint">
          ערכי ברירת המחדל:
          N50 = {גילוי:1.0, הכרה:4.0, זיהוי:6.4}, מקדם 90%: 1.75, CD: אדם 0.75m, רכב 2.3m.
          ניתן להתאים לפי “תורה”/מסמך דרישות אצלך.
        </div>

        <div style="height:10px;"></div>

        <div class="mini4">
          <div>
            <label>N50 גילוי (cycles)</label>
            <input id="N50_det" type="number" step="0.1" min="0.1" value="1.0" />
          </div>
          <div>
            <label>N50 הכרה (cycles)</label>
            <input id="N50_rec" type="number" step="0.1" min="0.1" value="4.0" />
          </div>
          <div>
            <label>N50 זיהוי (cycles)</label>
            <input id="N50_id" type="number" step="0.1" min="0.1" value="6.4" />
          </div>
          <div>
            <label>מקדם 90% (K)</label>
            <input id="K90" type="number" step="0.01" min="1.0" value="1.75" />
          </div>
        </div>

        <div style="height:10px;"></div>

        <div class="mini3">
          <div>
            <label>CD אדם (m)</label>
            <input id="CD_human" type="number" step="0.01" min="0.1" value="0.75" />
          </div>
          <div>
            <label>CD רכב (m)</label>
            <input id="CD_vehicle" type="number" step="0.01" min="0.1" value="2.30" />
          </div>
          <div>
            <label>הערה</label>
            <input disabled value="נוסחה: GSDmax = CD / (2·N)" />
          </div>
        </div>

        <div class="hint" style="margin-top:10px;">
          אם תרצה לעבוד ב-line-pairs במקום cycles: ניתן להמיר, אך כאן נשמרת עקביות עם המודל הפשוט (cycles על הממד הקריטי).
        </div>
      </details>

    </div>
  </section>

</main>

<script>
(function(){
  // -----------------------------
  // Helpers
  // -----------------------------
  const $ = (id)=>document.getElementById(id);
  const rad = (deg)=>deg*Math.PI/180;
  const deg = (rad)=>rad*180/Math.PI;

  function clamp(x, a, b){ return Math.max(a, Math.min(b, x)); }
  function fmt(x, digits=3){
    if(!isFinite(x)) return "—";
    const abs = Math.abs(x);
    if(abs >= 1000) return x.toFixed(1);
    if(abs >= 100) return x.toFixed(2);
    if(abs >= 10) return x.toFixed(3);
    return x.toFixed(digits);
  }
  function polygonArea(pts){
    let a=0;
    for(let i=0;i<pts.length;i++){
      const j=(i+1)%pts.length;
      a += pts[i].x*pts[j].y - pts[j].x*pts[i].y;
    }
    return Math.abs(a)/2;
  }
  function dist2(a,b){
    const dx=a.x-b.x, dy=a.y-b.y;
    return Math.hypot(dx,dy);
  }

  // Rotate vector around Y axis by beta (rad). Coordinates:
  // X forward, Y right, Z up.
  function rotY(v, beta){
    const c=Math.cos(beta), s=Math.sin(beta);
    return { x: v.x*c + v.z*s, y: v.y, z: -v.x*s + v.z*c };
  }

  // Intersect ray from camera (0,0,H) with ground plane Z=0.
  function intersectGround(H, dir){
    const dz = dir.z;
    if(Math.abs(dz) < 1e-9) return null;
    const t = (0 - H) / dz;
    if(t <= 0) return null;
    return { x: dir.x*t, y: dir.y*t };
  }

  function cornerRaysFromFov(hfov, vfov){
    const th = Math.tan(hfov/2);
    const tv = Math.tan(vfov/2);
    return [
      {x:1, y:-th, z: +tv}, // TL
      {x:1, y:+th, z: +tv}, // TR
      {x:1, y:+th, z: -tv}, // BR
      {x:1, y:-th, z: -tv}, // BL
    ];
  }

  function normalize(v){
    const n = Math.hypot(v.x,v.y,v.z);
    return {x:v.x/n, y:v.y/n, z:v.z/n};
  }

  // -----------------------------
  // UI mode switching
  // -----------------------------
  let mode = "fov"; // "fov" | "focal"
  const btnFov = $("btnFov");
  const btnFocal = $("btnFocal");
  const modeFov = $("modeFov");
  const modeFocal = $("modeFocal");

  function setMode(m){
    mode = m;
    btnFov.classList.toggle("active", mode==="fov");
    btnFocal.classList.toggle("active", mode==="focal");
    modeFov.style.display = (mode==="fov") ? "" : "none";
    modeFocal.style.display = (mode==="focal") ? "" : "none";
    compute();
  }

  btnFov.addEventListener("click", ()=>setMode("fov"));
  btnFocal.addEventListener("click", ()=>setMode("focal"));

  // -----------------------------
  // Johnson model state
  // -----------------------------
  const johnson = {
    // stored latest values to compute Rmax relative to slant range and selected gsd
    currentSlant: NaN,
    gsd: { x_avg: NaN, x_far: NaN, x_near: NaN, y_avg: NaN }
  };

  function getJohnsonParams(){
    const N50_det = Math.max(0.1, parseFloat($("N50_det").value||"1"));
    const N50_rec = Math.max(0.1, parseFloat($("N50_rec").value||"4"));
    const N50_id  = Math.max(0.1, parseFloat($("N50_id").value||"6.4"));
    const K90     = Math.max(1.0, parseFloat($("K90").value||"1.75"));
    const CD_h    = Math.max(0.1, parseFloat($("CD_human").value||"0.75"));
    const CD_v    = Math.max(0.1, parseFloat($("CD_vehicle").value||"2.3"));

    return { N50_det, N50_rec, N50_id, K90, CD_h, CD_v };
  }

  function buildJohnsonRows(){
    const { N50_det, N50_rec, N50_id, K90, CD_h, CD_v } = getJohnsonParams();
    const prob = $("probMode").value; // "50" or "90"
    const is90 = (prob === "90");
    const k = is90 ? K90 : 1.0;
    const probLabel = is90 ? "90%" : "50%";

    const tasks = [
      { key:"det", label:"גילוי",  N50:N50_det },
      { key:"rec", label:"הכרה",  N50:N50_rec },
      { key:"id",  label:"זיהוי", N50:N50_id  },
    ];
    const targets = [
      { key:"human", label:"אדם",  CD:CD_h },
      { key:"veh",   label:"רכב",  CD:CD_v },
    ];

    const gsdKey = $("gsdSource").value; // x_avg / x_far / x_near / y_avg
    const gsdNow = johnson.gsd[gsdKey];
    const Rnow = johnson.currentSlant;

    const out = [];
    for(const t of targets){
      for(const task of tasks){
        const Nreq = task.N50 * k;
        const GSDmax = t.CD / (2 * Nreq); // m/px
        const pass = isFinite(gsdNow) ? (gsdNow <= GSDmax) : false;

        const Rmax = (isFinite(Rnow) && isFinite(gsdNow) && gsdNow>0)
          ? (Rnow * (GSDmax / gsdNow))
          : NaN;

        out.push({
          target: t.label,
          task: task.label,
          cd: t.CD,
          prob: probLabel,
          nreq: Nreq,
          gsdNow,
          gsdMax: GSDmax,
          rmax: Rmax,
          pass
        });
      }
    }
    return out;
  }

  function renderJohnson(){
    const body = $("johnsonBody");
    if(!body) return;
    body.innerHTML = "";

    const rows = buildJohnsonRows();

    // headline
    const gsdKey = $("gsdSource").value;
    const gsdNow = johnson.gsd[gsdKey];
    const Rnow = johnson.currentSlant;
    $("johnsonLine").textContent = `GSD נבחר=${fmt(gsdNow,6)} m/px | Slant Range=${fmt(Rnow,3)} m`;

    for(const r of rows){
      const tr = document.createElement("tr");
      tr.className = r.pass ? "j-pass" : "j-fail";

      const statusPill = r.pass
        ? `<span class="pill pass">PASS</span>`
        : `<span class="pill fail">FAIL</span>`;

      tr.innerHTML = `
        <td class="mono">${fmt(r.rmax,3)}</td>
        <td>${statusPill}</td>
        <td class="mono">${fmt(r.gsdMax,6)}</td>
        <td class="mono">${fmt(r.gsdNow,6)}</td>
        <td class="mono">${fmt(r.nreq,3)}</td>
        <td>${r.prob}</td>
        <td>${r.task}</td>
        <td>${r.target}</td>
        <td class="mono">${fmt(r.cd,3)}</td>
      `;
      body.appendChild(tr);
    }
  }

  // -----------------------------
  // Main compute
  // -----------------------------
  function compute(){
    const pxW = Math.max(1, parseInt($("pxW").value||"1",10));
    const pxH = Math.max(1, parseInt($("pxH").value||"1",10));
    const H = Math.max(0.01, parseFloat($("altM").value||"0.01"));

    const lookDeg = clamp(parseFloat($("lookDeg").value||"-90"), -90, 0);
    const pitchDownDeg = -lookDeg;
    const beta = rad(pitchDownDeg);

    let hfovDeg, vfovDeg;

    if(mode==="fov"){
      hfovDeg = clamp(parseFloat($("hfovDeg").value||"60"), 1, 179);
      vfovDeg = clamp(parseFloat($("vfovDeg").value||"35"), 1, 179);
    }else{
      const sensorW = Math.max(0.01, parseFloat($("sensorWmm").value||"1"));
      const sensorH = Math.max(0.01, parseFloat($("sensorHmm").value||"1"));
      const focal = Math.max(0.01, parseFloat($("focalMm").value||"1"));

      const hfov = 2*Math.atan(sensorW/(2*focal));
      const vfov = 2*Math.atan(sensorH/(2*focal));
      hfovDeg = deg(hfov);
      vfovDeg = deg(vfov);
    }

    const hfov = rad(hfovDeg);
    const vfov = rad(vfovDeg);

    const status = $("statusLine");
    const fovEcho = $("fovEcho");
    fovEcho.textContent = `HFOV=${fmt(hfovDeg,2)}° , VFOV=${fmt(vfovDeg,2)}°`;

    // Center ray
    const centerCam = {x:1, y:0, z:0};
    const centerWorld = rotY(centerCam, beta);
    const centerHit = intersectGround(H, centerWorld);

    const centerWorldN = normalize(centerWorld);
    const centerHitN = intersectGround(H, centerWorldN);
    let slant = NaN;
    if(centerHitN){
      slant = (-H) / centerWorldN.z;
    }

    if(!centerHit || !isFinite(slant) || slant<=0){
      status.textContent = "שגיאה גיאומטרית: הזווית קרובה מדי לאופק או הקרניים לא פוגעות בקרקע.";
      status.className = "small bad";
      renderEmpty();
      // Update Johnson as empty
      johnson.currentSlant = NaN;
      johnson.gsd.x_avg = NaN; johnson.gsd.x_far = NaN; johnson.gsd.x_near = NaN; johnson.gsd.y_avg = NaN;
      renderJohnson();
      return;
    }else{
      status.textContent = "מחושב";
      status.className = "small ok";
    }

    // Corner intersections (4 corners)
    const raysCam = cornerRaysFromFov(hfov, vfov);
    const hits = [];
    for(const rc of raysCam){
      const rw = rotY(rc, beta);
      const rwn = normalize(rw);
      const hit = intersectGround(H, rwn);
      if(!hit){
        status.textContent = "הערה: אחת מפינות הפריים לא פוגעת בקרקע (זווית קרובה לאופק / FOV רחב).";
        status.className = "small warn";
        break;
      }
      hits.push(hit);
    }

    let area = NaN, depth = NaN, wNear = NaN, wFar = NaN;

    if(hits.length === 4){
      const TL=hits[0], TR=hits[1], BR=hits[2], BL=hits[3];

      area = polygonArea([TL,TR,BR,BL]);

      const farMid = {x:(TL.x+TR.x)/2, y:(TL.y+TR.y)/2};
      const nearMid = {x:(BL.x+BR.x)/2, y:(BL.y+BR.y)/2};
      depth = Math.hypot(farMid.x-nearMid.x, farMid.y-nearMid.y);

      wFar = dist2(TL,TR);
      wNear = dist2(BL,BR);
    }

    // GSD calculations
    const gsdX_far = (isFinite(wFar) ? (wFar/pxW) : NaN);
    const gsdX_near = (isFinite(wNear) ? (wNear/pxW) : NaN);
    const gsdX_avg = (isFinite(wFar) && isFinite(wNear)) ? ((wFar+wNear)/2/pxW) : NaN;

    const gsdY_avg = isFinite(depth) ? (depth/pxH) : NaN;

    // Populate outputs
    $("slant").textContent = fmt(slant,3);
    $("centerX").textContent = fmt(centerHit.x,3);
    $("area").textContent = fmt(area,3);

    if(isFinite(wNear) && isFinite(wFar)){
      $("wNearFar").textContent = `${fmt(wNear,3)} → ${fmt(wFar,3)}`;
    }else{
      $("wNearFar").textContent = "—";
    }

    $("depth").textContent = fmt(depth,3);

    $("gsdXavg").textContent = fmt(gsdX_avg,6);
    $("gsdXavgCm").textContent = isFinite(gsdX_avg) ? fmt(gsdX_avg*100,4) : "—";
    $("gsdXminmax").textContent = (isFinite(gsdX_far) && isFinite(gsdX_near))
      ? `${fmt(gsdX_far,6)} → ${fmt(gsdX_near,6)}`
      : "—";

    $("gsdYavg").textContent = fmt(gsdY_avg,6);
    $("gsdYavgCm").textContent = isFinite(gsdY_avg) ? fmt(gsdY_avg*100,4) : "—";

    // Store for Johnson
    johnson.currentSlant = slant;
    johnson.gsd.x_avg = gsdX_avg;
    johnson.gsd.x_far = gsdX_far;
    johnson.gsd.x_near = gsdX_near;
    johnson.gsd.y_avg = gsdY_avg;

    // Render visualization
    renderViz({H, lookDeg, pitchDownDeg, hfovDeg, vfovDeg, centerHit, hits});

    // Render Johnson
    renderJohnson();
  }

  function renderEmpty(){
    for(const id of ["slant","centerX","area","wNearFar","depth","gsdXavg","gsdXavgCm","gsdXminmax","gsdYavg","gsdYavgCm"]){
      $(id).textContent="—";
    }
    const svg = $("viz");
    svg.innerHTML = `<rect x="0" y="0" width="920" height="420" fill="rgba(255,255,255,.02)"></rect>
      <text x="460" y="210" text-anchor="middle" fill="rgba(238,242,255,.75)" font-size="14">
        אין חיתוך קרניים תקין עם הקרקע עבור הפרמטרים הנוכחיים.
      </text>`;
  }

  function renderViz(ctx){
    const svg = $("viz");
    const W=920, Hs=420;

    const groundY = 360;
    const camX = 110;
    const camZpx = 90;

    let xMax = Math.max(ctx.centerHit.x, 1);
    if(ctx.hits && ctx.hits.length===4){
      for(const p of ctx.hits) xMax = Math.max(xMax, p.x);
    }
    xMax *= 1.15;

    const x2px = (x)=> camX + (x/xMax) * (W-180);
    const z2px = (z)=> groundY - (z/ctx.H) * (groundY-camZpx);

    const beta = rad(-ctx.lookDeg);
    const vfov = rad(ctx.vfovDeg);
    const tv = Math.tan(vfov/2);

    const topCam = normalize({x:1,y:0,z:+tv});
    const botCam = normalize({x:1,y:0,z:-tv});
    const centerCam = normalize({x:1,y:0,z:0});

    function rotY2(v, beta){
      const c=Math.cos(beta), s=Math.sin(beta);
      return { x: v.x*c + v.z*s, y:v.y, z: -v.x*s + v.z*c };
    }
    function intersectGroundLocal(H, dir){
      if(Math.abs(dir.z)<1e-9) return null;
      const t = (0 - H)/dir.z;
      if(t<=0) return null;
      return { x: dir.x*t, z: 0 };
    }

    const cW = rotY2(centerCam, beta);
    const tW = rotY2(topCam, beta);
    const bW = rotY2(botCam, beta);

    const cHit = intersectGroundLocal(ctx.H, cW);
    const tHit = intersectGroundLocal(ctx.H, tW);
    const bHit = intersectGroundLocal(ctx.H, bW);

    const camPt = {x:0,z:ctx.H};

    let widthNote = "";
    if(ctx.hits && ctx.hits.length===4){
      const TL=ctx.hits[0], TR=ctx.hits[1], BR=ctx.hits[2], BL=ctx.hits[3];
      const wFar = Math.hypot(TL.x-TR.x, TL.y-TR.y);
      const wNear = Math.hypot(BL.x-BR.x, BL.y-BR.y);
      widthNote = `רוחב קרוב≈${fmt(wNear,2)}m, רוחב רחוק≈${fmt(wFar,2)}m`;
    }

    svg.innerHTML = `
      <rect x="0" y="0" width="${W}" height="${Hs}" fill="rgba(255,255,255,.02)"></rect>

      <line x1="50" y1="${groundY}" x2="${W-40}" y2="${groundY}" stroke="rgba(255,255,255,.18)" stroke-width="2" />
      <text x="${W-45}" y="${groundY-10}" text-anchor="end" fill="rgba(168,179,214,.85)" font-size="12">קרקע (Z=0)</text>

      <circle cx="${x2px(camPt.x)}" cy="${z2px(camPt.z)}" r="6" fill="rgba(238,242,255,.9)"></circle>
      <text x="${x2px(camPt.x)+10}" y="${z2px(camPt.z)-10}" fill="rgba(238,242,255,.85)" font-size="12">
        מצלמה (גובה ${fmt(ctx.H,2)}m)
      </text>

      ${cHit ? `<line x1="${x2px(camPt.x)}" y1="${z2px(camPt.z)}" x2="${x2px(cHit.x)}" y2="${groundY}"
        stroke="rgba(51,209,122,.9)" stroke-width="2"/>` : ""}

      ${tHit ? `<line x1="${x2px(camPt.x)}" y1="${z2px(camPt.z)}" x2="${x2px(tHit.x)}" y2="${groundY}"
        stroke="rgba(255,255,255,.35)" stroke-width="2"/>` : ""}

      ${bHit ? `<line x1="${x2px(camPt.x)}" y1="${z2px(camPt.z)}" x2="${x2px(bHit.x)}" y2="${groundY}"
        stroke="rgba(255,255,255,.35)" stroke-width="2"/>` : ""}

      ${cHit ? `<circle cx="${x2px(cHit.x)}" cy="${groundY}" r="5" fill="rgba(51,209,122,.95)"></circle>` : ""}

      <text x="60" y="40" fill="rgba(238,242,255,.85)" font-size="14" font-weight="650">תרשים צד (X-Z)</text>
      <text x="60" y="64" fill="rgba(168,179,214,.85)" font-size="12">
        זווית הסתכלות: ${fmt(ctx.lookDeg,2)}° | HFOV=${fmt(ctx.hfovDeg,2)}° VFOV=${fmt(ctx.vfovDeg,2)}°
      </text>
      <text x="60" y="86" fill="rgba(168,179,214,.85)" font-size="12">
        ${widthNote}
      </text>

      <text x="${W-45}" y="40" text-anchor="end" fill="rgba(168,179,214,.75)" font-size="12">
        סקייל דיאגרמה: xMax≈${fmt(xMax,1)}m
      </text>
    `;
  }

  // Hook up live updates
  const inputs = [
    "pxW","pxH","altM","lookDeg","hfovDeg","vfovDeg","sensorWmm","sensorHmm","focalMm",
    "gsdSource","probMode",
    "N50_det","N50_rec","N50_id","K90","CD_human","CD_vehicle"
  ];
  inputs.forEach(id=>{
    const el = $(id);
    if(!el) return;
    el.addEventListener("input", compute);   // compute also refreshes Johnson
    el.addEventListener("change", compute);
  });

  // initial
  compute();
})();
</script>
</body>
</html>
