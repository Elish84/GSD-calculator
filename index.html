<!doctype html>
<html lang="he" dir="rtl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title data-i18n="app.title">מחשבון GSD (Ground Sample Distance)</title>
  <style>
    :root{
      --bg:#0b1020; --card:#121a33; --muted:#a8b3d6; --text:#eef2ff;
      --line:rgba(255,255,255,.12);
      --good:#33d17a; --warn:#ffb020; --bad:#ff4d4d;
      --radius:16px;
    }
    *{ box-sizing:border-box; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    body{ margin:0; background:linear-gradient(180deg,#070a14,#0b1020 45%,#070a14); color:var(--text); }
    header{
      position:sticky; top:0; z-index:50; backdrop-filter: blur(10px);
      background:rgba(11,16,32,.65); border-bottom:1px solid var(--line);
    }
    .wrap{ max-width:1100px; margin:0 auto; padding:16px; }
    h1{ margin:0; font-size:20px; letter-spacing:.2px; }
    .sub{ margin-top:6px; color:var(--muted); font-size:13px; }
    .grid{
      display:grid; gap:12px; margin-top:14px;
      grid-template-columns: 1.1fr .9fr;
    }
    @media (max-width: 980px){ .grid{ grid-template-columns:1fr; } }
    .card{
      background:rgba(18,26,51,.72);
      border:1px solid var(--line);
      border-radius:var(--radius);
      box-shadow: 0 10px 25px rgba(0,0,0,.25);
      overflow:hidden;
    }
    .card .hd{
      padding:14px 14px 10px;
      border-bottom:1px solid var(--line);
      display:flex; justify-content:space-between; align-items:flex-start; gap:10px;
    }
    .card .hd .t{ font-weight:700; }
    .card .bd{ padding:14px; }
    .row{ display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
    @media (max-width: 520px){ .row{ grid-template-columns:1fr; } }
    label{ display:block; font-size:12px; color:var(--muted); margin-bottom:6px; }
    input, select{
      width:100%; padding:10px 10px;
      border-radius:12px;
      border:1px solid var(--line);
      background:rgba(255,255,255,.06);
      color:var(--text);
      outline:none;
    }
    input:focus, select:focus{ border-color: rgba(168,179,214,.45); box-shadow: 0 0 0 3px rgba(168,179,214,.15); }
    .seg{
      display:flex; gap:8px; flex-wrap:wrap;
      background:rgba(255,255,255,.05);
      border:1px solid var(--line);
      padding:8px; border-radius:14px;
    }
    .seg button{
      flex:1; min-width:160px;
      border:1px solid transparent;
      border-radius:12px;
      padding:9px 10px;
      background:rgba(255,255,255,.06);
      color:var(--text);
      cursor:pointer;
    }
    .seg button.active{
      background:rgba(51,209,122,.14);
      border-color: rgba(51,209,122,.35);
    }
    .note{
      margin-top:10px; color:var(--muted); font-size:12px; line-height:1.45;
    }
    table{
      width:100%; border-collapse: collapse; overflow:hidden;
      border-radius:12px; border:1px solid var(--line);
    }
    th, td{
      padding:10px 10px;
      border-bottom:1px solid var(--line);
      font-size:13px;
      vertical-align:top;
    }
    th{ text-align:start; color:var(--muted); background:rgba(255,255,255,.04); font-weight:650; }
    tr:last-child td{ border-bottom:none; }
    .badge{
      display:inline-block; padding:2px 8px; border-radius:999px;
      border:1px solid var(--line); font-size:12px; color:var(--muted);
      background:rgba(255,255,255,.04);
      margin-inline-start:8px;
    }
    .ok{ color: var(--good); }
    .warn{ color: var(--warn); }
    .bad{ color: var(--bad); }
    .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }
    .svgBox{
      border:1px solid var(--line);
      background:rgba(255,255,255,.03);
      border-radius:12px;
      overflow:hidden;
    }
    .foot{
      margin-top:12px; padding-top:10px; border-top:1px solid var(--line);
      color:var(--muted); font-size:12px; line-height:1.45;
    }
    .small{ font-size:12px; color:var(--muted); }

    /* Johnson table highlighting */
    .j-pass td{ background: rgba(51,209,122,.10); }
    .j-fail td{ background: rgba(255,77,77,.10); }

    .pill{
      display:inline-block;
      padding:2px 8px;
      border-radius:999px;
      border:1px solid var(--line);
      font-size:12px;
      background:rgba(255,255,255,.04);
    }
    .pill.pass{ color: var(--good); border-color: rgba(51,209,122,.35); background:rgba(51,209,122,.10); }
    .pill.fail{ color: var(--bad); border-color: rgba(255,77,77,.35); background:rgba(255,77,77,.10); }
    details{ border:1px solid var(--line); border-radius:12px; padding:10px 12px; background:rgba(255,255,255,.03); }
    summary{ cursor:pointer; color:var(--text); font-weight:650; }
    .hint{ color:var(--muted); font-size:12px; margin-top:6px; line-height:1.45; }
    .mini3{ display:grid; grid-template-columns: 1fr 1fr 1fr; gap:10px; }
    @media (max-width: 860px){ .mini3{ grid-template-columns:1fr; } }
    .mini4{ display:grid; grid-template-columns: 1fr 1fr 1fr 1fr; gap:10px; }
    @media (max-width: 980px){ .mini4{ grid-template-columns:1fr; } }

    /* Language switch */
    .topline{
      display:flex;
      justify-content:space-between;
      align-items:flex-start;
      gap:12px;
    }
    .langSwitch{
      display:flex;
      gap:8px;
      align-items:center;
    }
    .langSwitch .lbl{
      color:var(--muted);
      font-size:12px;
      margin-top:2px;
    }
    .langSwitch button{
      border:1px solid var(--line);
      border-radius:12px;
      padding:7px 10px;
      background:rgba(255,255,255,.06);
      color:var(--text);
      cursor:pointer;
      font-size:12px;
    }
    .langSwitch button.active{
      background:rgba(74,163,255,.16);
      border-color: rgba(74,163,255,.38);
    }
  </style>
</head>
<body>
<header>
  <div class="wrap">
    <div class="topline">
      <div>
        <h1 data-i18n="app.title">מחשבון GSD (Ground Sample Distance)</h1>
        <div class="sub">
          <span data-i18n="app.subtitleA">מודל פין-הול, קרקע מישורית.</span>
          <span data-i18n="app.subtitleB">זווית הסתכלות:</span>
          <span class="mono" data-i18n="app.subtitleC">0° = אופק</span>,
          <span class="mono" data-i18n="app.subtitleD">-90° = למטה</span>.
          <span class="badge" data-i18n="app.badge">GitHub Pages Ready</span>
        </div>
      </div>

      <div class="langSwitch" aria-label="Language switch">
        <div class="lbl" data-i18n="lang.label">שפה</div>
        <button id="langHe" type="button">עברית</button>
        <button id="langEn" type="button">English</button>
      </div>
    </div>
  </div>
</header>

<main class="wrap">
  <div class="grid">
    <!-- Inputs -->
    <section class="card">
      <div class="hd">
        <div class="t" data-i18n="inputs.title">קלטים</div>
        <div class="small" id="statusLine" data-i18n="status.loading">טוען…</div>
      </div>
      <div class="bd">
        <div class="row">
          <div>
            <label data-i18n="inputs.pxW">רזולוציה אופקית (px)</label>
            <input id="pxW" type="number" min="1" step="1" value="3840" />
          </div>
          <div>
            <label data-i18n="inputs.pxH">רזולוציה אנכית (px)</label>
            <input id="pxH" type="number" min="1" step="1" value="2160" />
          </div>
        </div>

        <div class="row" style="margin-top:10px;">
          <div>
            <label data-i18n="inputs.alt">גובה מעל הקרקע (m)</label>
            <input id="altM" type="number" min="0.1" step="0.1" value="120" />
          </div>
          <div>
            <label data-i18n="inputs.look">זווית הסתכלות (deg) — 0 אופק, -90 למטה</label>
            <input id="lookDeg" type="number" min="-90" max="0" step="0.1" value="-90" />
          </div>
        </div>

        <div style="margin-top:12px;">
          <label data-i18n="inputs.method">שיטת הזנת שדה ראייה / אופטיקה</label>
          <div class="seg">
            <button id="btnFov" class="active" type="button" data-i18n="inputs.modeFovBtn">HFOV/VFOV (מעלות)</button>
            <button id="btnFocal" type="button" data-i18n="inputs.modeFocalBtn">חיישן + אורך מוקד (mm)</button>
          </div>
        </div>

        <!-- FOV mode -->
        <div id="modeFov" style="margin-top:12px;">
          <div class="row">
            <div>
              <label data-i18n="inputs.hfov">HFOV (מעלות)</label>
              <input id="hfovDeg" type="number" min="1" max="179" step="0.1" value="60" />
            </div>
            <div>
              <label data-i18n="inputs.vfov">VFOV (מעלות)</label>
              <input id="vfovDeg" type="number" min="1" max="179" step="0.1" value="35" />
            </div>
          </div>
          <div class="note" data-i18n="inputs.fovNote">
            אם יש לך רק HFOV, תוכל להעריך VFOV לפי יחס הרזולוציה (או להזין ידנית).
          </div>
        </div>

        <!-- Focal mode -->
        <div id="modeFocal" style="margin-top:12px; display:none;">
          <div class="row">
            <div>
              <label data-i18n="inputs.sensorW">רוחב חיישן (mm)</label>
              <input id="sensorWmm" type="number" min="0.1" step="0.01" value="6.4" />
            </div>
            <div>
              <label data-i18n="inputs.sensorH">גובה חיישן (mm)</label>
              <input id="sensorHmm" type="number" min="0.1" step="0.01" value="4.8" />
            </div>
          </div>
          <div class="row" style="margin-top:10px;">
            <div>
              <label data-i18n="inputs.focal">אורך מוקד (mm)</label>
              <input id="focalMm" type="number" min="0.1" step="0.01" value="8.0" />
            </div>
            <div>
              <label data-i18n="inputs.autoNoteLbl">הערה</label>
              <input disabled data-i18n-value="inputs.autoNoteVal" value="HFOV/VFOV יחושבו אוטומטית מהנתונים" />
            </div>
          </div>
          <div class="note">
            <span data-i18n="inputs.focalFormulaPrefix">חישוב:</span>
            <span class="mono">FOV = 2·atan(sensor/(2·focal))</span>.
          </div>
        </div>

        <div class="foot" data-i18n="inputs.assumptions">
          הנחות: קרקע מישורית, ציר המצלמה ללא Roll, “Forward” הוא כיוון התצפית. בזוויות אלכסוניות ה-GSD אינו אחיד, לכן מוצג גם טווח (קרוב/רחוק).
        </div>
      </div>
    </section>

    <!-- Outputs -->
    <section class="card">
      <div class="hd">
        <div class="t" data-i18n="outputs.title">תוצאות</div>
        <div class="small" id="fovEcho">—</div>
      </div>
      <div class="bd">
        <table>
          <tbody>
            <tr>
              <th data-i18n="outputs.slant">Slant Range (לציר המרכזי)</th>
              <td><span id="slant" class="mono">—</span> <span class="small">m</span></td>
            </tr>
            <tr>
              <th data-i18n="outputs.forward">Forward distance (פגיעה של הציר המרכזי)</th>
              <td><span id="centerX" class="mono">—</span> <span class="small">m</span></td>
            </tr>
            <tr>
              <th data-i18n="outputs.area">Footprint Area (פוליגון 4 פינות)</th>
              <td><span id="area" class="mono">—</span> <span class="small">m²</span></td>
            </tr>
            <tr>
              <th data-i18n="outputs.width">Footprint Width (שמאל-ימין)</th>
              <td><span id="wNearFar" class="mono">—</span> <span class="small" data-i18n="outputs.nearToFar">m (קרוב→רחוק)</span></td>
            </tr>
            <tr>
              <th data-i18n="outputs.depth">Footprint Depth (קדימה)</th>
              <td><span id="depth" class="mono">—</span> <span class="small">m</span></td>
            </tr>
            <tr>
              <th data-i18n="outputs.gsdx">GSD X (רוחבי)</th>
              <td>
                <div><span id="gsdXavg" class="mono">—</span> <span class="small">m/px</span> (<span id="gsdXavgCm" class="mono">—</span> <span class="small">cm/px</span>)</div>
                <div class="small"><span data-i18n="outputs.range">טווח:</span> <span id="gsdXminmax" class="mono">—</span> <span>m/px</span> <span data-i18n="outputs.farToNear">(רחוק→קרוב)</span></div>
              </td>
            </tr>
            <tr>
              <th data-i18n="outputs.gsdy">GSD Y (אורכי)</th>
              <td>
                <div><span id="gsdYavg" class="mono">—</span> <span class="small">m/px</span> (<span id="gsdYavgCm" class="mono">—</span> <span class="small">cm/px</span>)</div>
                <div class="small" data-i18n="outputs.gsdyNote">בקירוב (הקרנה אלכסונית גורמת לשונות לאורך הפריים)</div>
              </td>
            </tr>
          </tbody>
        </table>

        <div style="height:12px;"></div>
        <div class="svgBox">
          <svg id="viz" viewBox="0 0 920 420" width="100%" height="auto" aria-label="Geometry diagram">
            <!-- Filled by JS -->
          </svg>
        </div>

        <div class="note" data-i18n="outputs.calcNote">
          לצרכי חישוב: נקודות הפוליגון מתקבלות מחיתוך הקרניים (פינות הפריים) עם מישור הקרקע.
          ה-GSD הרוחבי מחושב לכל אחת מהשורות (העליונה=רחוק, התחתונה=קרוב) לפי רוחב בשטח חלקי פיקסלים.
        </div>
      </div>
    </section>
  </div>

  <!-- Johnson / DRI section -->
  <section class="card" style="margin-top:12px;">
    <div class="hd">
      <div class="t" data-i18n="johnson.title">קריטריון ג׳ונסון (DRI) — התאמה לפי GSD</div>
      <div class="small" id="johnsonLine">—</div>
    </div>
    <div class="bd">

      <div class="row">
        <div>
          <label data-i18n="johnson.gsdSelectLbl">בחר איזה GSD להזין לטבלת ג׳ונסון</label>
          <select id="gsdSource">
            <option value="x_avg" selected data-i18n="johnson.opt.xavg">GSD X avg (מומלץ כברירת מחדל)</option>
            <option value="x_far" data-i18n="johnson.opt.xfar">GSD X far (שורה עליונה=רחוק)</option>
            <option value="x_near" data-i18n="johnson.opt.xnear">GSD X near (שורה תחתונה=קרוב)</option>
            <option value="y_avg" data-i18n="johnson.opt.yavg">GSD Y avg (בקירוב)</option>
          </select>
          <div class="hint" data-i18n="johnson.hintA">הטבלה מניחה יחס ליניארי: Rmax = Rnow · (GSDmax/GSDnow). כאן Rnow הוא Slant Range של ציר המרכזי.</div>
        </div>

        <div>
          <label data-i18n="johnson.thrLbl">סף הצלחה</label>
          <select id="probMode">
            <option value="50" selected>50%</option>
            <option value="90">90%</option>
          </select>
          <div class="hint" data-i18n="johnson.hintB">ב-90% משתמשים במקדם N90 = N50 · K (ניתן לשינוי בהגדרות למטה).</div>
        </div>
      </div>

      <div style="height:12px;"></div>

      <table aria-label="Johnson DRI table">
        <thead>
          <tr>
            <th style="width:16%;" data-i18n="johnson.th.rmax">טווח מקסימלי (m)</th>
            <th style="width:10%;" data-i18n="johnson.th.status">סטטוס</th>
            <th style="width:14%;" data-i18n="johnson.th.gsdmax">GSDmax (m/px)</th>
            <th style="width:14%;" data-i18n="johnson.th.gsdnow">GSD בפועל (m/px)</th>
            <th style="width:10%;" data-i18n="johnson.th.nreq">N נדרש</th>
            <th style="width:10%;" data-i18n="johnson.th.prob">הסתברות</th>
            <th style="width:12%;" data-i18n="johnson.th.task">משימה</th>
            <th style="width:10%;" data-i18n="johnson.th.target">מטרה</th>
            <th style="width:14%;" data-i18n="johnson.th.cd">CD (m)</th>
          </tr>
        </thead>
        <tbody id="johnsonBody">
          <!-- Filled by JS -->
        </tbody>
      </table>

      <div style="height:12px;"></div>

      <details>
        <summary data-i18n="johnson.detailsTitle">הגדרות ג׳ונסון — עריכה</summary>

        <div class="hint" data-i18n="johnson.defaults">
          ערכי ברירת המחדל:
          N50 = {גילוי:1.0, הכרה:4.0, זיהוי:6.4}, מקדם 90%: 1.75, CD: אדם 0.75m, רכב 2.3m.
          ניתן להתאים לפי “תורה”/מסמך דרישות אצלך.
        </div>

        <div style="height:10px;"></div>

        <div class="mini4">
          <div>
            <label data-i18n="johnson.N50det">N50 גילוי (cycles)</label>
            <input id="N50_det" type="number" step="0.1" min="0.1" value="1.0" />
          </div>
          <div>
            <label data-i18n="johnson.N50rec">N50 הכרה (cycles)</label>
            <input id="N50_rec" type="number" step="0.1" min="0.1" value="4.0" />
          </div>
          <div>
            <label data-i18n="johnson.N50id">N50 זיהוי (cycles)</label>
            <input id="N50_id" type="number" step="0.1" min="0.1" value="6.4" />
          </div>
          <div>
            <label data-i18n="johnson.K90">מקדם 90% (K)</label>
            <input id="K90" type="number" step="0.01" min="1.0" value="1.75" />
          </div>
        </div>

        <div style="height:10px;"></div>

        <div class="mini3">
          <div>
            <label data-i18n="johnson.CDhuman">CD אדם (m)</label>
            <input id="CD_human" type="number" step="0.01" min="0.1" value="0.75" />
          </div>
          <div>
            <label data-i18n="johnson.CDveh">CD רכב (m)</label>
            <input id="CD_vehicle" type="number" step="0.01" min="0.1" value="2.30" />
          </div>
          <div>
            <label data-i18n="johnson.formulaLbl">הערה</label>
            <input disabled data-i18n-value="johnson.formulaVal" value="נוסחה: GSDmax = CD / (2·N)" />
          </div>
        </div>

        <div class="hint" style="margin-top:10px;" data-i18n="johnson.lpHint">
          אם תרצה לעבוד ב-line-pairs במקום cycles: ניתן להמיר, אך כאן נשמרת עקביות עם המודל הפשוט (cycles על הממד הקריטי).
        </div>
      </details>

    </div>
  </section>

</main>

<script>
(function(){
  // -----------------------------
  // i18n
  // -----------------------------
  const I18N = {
    he: {
      "lang.label":"שפה",
      "app.title":"מחשבון GSD (Ground Sample Distance)",
      "app.subtitleA":"מודל פין-הול, קרקע מישורית.",
      "app.subtitleB":"זווית הסתכלות:",
      "app.subtitleC":"0° = אופק",
      "app.subtitleD":"-90° = למטה",
      "app.badge":"GitHub Pages Ready",

      "inputs.title":"קלטים",
      "status.loading":"טוען…",
      "status.ok":"מחושב",
      "status.warnCorner":"הערה: אחת מפינות הפריים לא פוגעת בקרקע (זווית קרובה לאופק / FOV רחב).",
      "status.geomError":"שגיאה גיאומטרית: הזווית קרובה מדי לאופק או הקרניים לא פוגעות בקרקע.",

      "inputs.pxW":"רזולוציה אופקית (px)",
      "inputs.pxH":"רזולוציה אנכית (px)",
      "inputs.alt":"גובה מעל הקרקע (m)",
      "inputs.look":"זווית הסתכלות (deg) — 0 אופק, -90 למטה",
      "inputs.method":"שיטת הזנת שדה ראייה / אופטיקה",
      "inputs.modeFovBtn":"HFOV/VFOV (מעלות)",
      "inputs.modeFocalBtn":"חיישן + אורך מוקד (mm)",
      "inputs.hfov":"HFOV (מעלות)",
      "inputs.vfov":"VFOV (מעלות)",
      "inputs.fovNote":"אם יש לך רק HFOV, תוכל להעריך VFOV לפי יחס הרזולוציה (או להזין ידנית).",
      "inputs.sensorW":"רוחב חיישן (mm)",
      "inputs.sensorH":"גובה חיישן (mm)",
      "inputs.focal":"אורך מוקד (mm)",
      "inputs.autoNoteLbl":"הערה",
      "inputs.autoNoteVal":"HFOV/VFOV יחושבו אוטומטית מהנתונים",
      "inputs.focalFormulaPrefix":"חישוב:",
      "inputs.assumptions":"הנחות: קרקע מישורית, ציר המצלמה ללא Roll, “Forward” הוא כיוון התצפית. בזוויות אלכסוניות ה-GSD אינו אחיד, לכן מוצג גם טווח (קרוב/רחוק).",

      "outputs.title":"תוצאות",
      "outputs.slant":"Slant Range (לציר המרכזי)",
      "outputs.forward":"Forward distance (פגיעה של הציר המרכזי)",
      "outputs.area":"Footprint Area (פוליגון 4 פינות)",
      "outputs.width":"Footprint Width (שמאל-ימין)",
      "outputs.nearToFar":"m (קרוב→רחוק)",
      "outputs.depth":"Footprint Depth (קדימה)",
      "outputs.gsdx":"GSD X (רוחבי)",
      "outputs.range":"טווח:",
      "outputs.farToNear":"(רחוק→קרוב)",
      "outputs.gsdy":"GSD Y (אורכי)",
      "outputs.gsdyNote":"בקירוב (הקרנה אלכסונית גורמת לשונות לאורך הפריים)",
      "outputs.calcNote":"לצרכי חישוב: נקודות הפוליגון מתקבלות מחיתוך הקרניים (פינות הפריים) עם מישור הקרקע. ה-GSD הרוחבי מחושב לכל אחת מהשורות (העליונה=רחוק, התחתונה=קרוב) לפי רוחב בשטח חלקי פיקסלים.",
      "outputs.noIntersect":"אין חיתוך קרניים תקין עם הקרקע עבור הפרמטרים הנוכחיים.",

      "johnson.title":"קריטריון ג׳ונסון (DRI) — התאמה לפי GSD",
      "johnson.gsdSelectLbl":"בחר איזה GSD להזין לטבלת ג׳ונסון",
      "johnson.opt.xavg":"GSD X avg (מומלץ כברירת מחדל)",
      "johnson.opt.xfar":"GSD X far (שורה עליונה=רחוק)",
      "johnson.opt.xnear":"GSD X near (שורה תחתונה=קרוב)",
      "johnson.opt.yavg":"GSD Y avg (בקירוב)",
      "johnson.hintA":"הטבלה מניחה יחס ליניארי: Rmax = Rnow · (GSDmax/GSDnow). כאן Rnow הוא Slant Range של ציר המרכזי.",
      "johnson.thrLbl":"סף הצלחה",
      "johnson.hintB":"ב-90% משתמשים במקדם N90 = N50 · K (ניתן לשינוי בהגדרות למטה).",
      "johnson.th.rmax":"טווח מקסימלי (m)",
      "johnson.th.status":"סטטוס",
      "johnson.th.gsdmax":"GSDmax (m/px)",
      "johnson.th.gsdnow":"GSD בפועל (m/px)",
      "johnson.th.nreq":"N נדרש",
      "johnson.th.prob":"הסתברות",
      "johnson.th.task":"משימה",
      "johnson.th.target":"מטרה",
      "johnson.th.cd":"CD (m)",
      "johnson.detailsTitle":"הגדרות ג׳ונסון — עריכה",
      "johnson.defaults":"ערכי ברירת המחדל: N50 = {גילוי:1.0, הכרה:4.0, זיהוי:6.4}, מקדם 90%: 1.75, CD: אדם 0.75m, רכב 2.3m. ניתן להתאים לפי “תורה”/מסמך דרישות אצלך.",
      "johnson.N50det":"N50 גילוי (cycles)",
      "johnson.N50rec":"N50 הכרה (cycles)",
      "johnson.N50id":"N50 זיהוי (cycles)",
      "johnson.K90":"מקדם 90% (K)",
      "johnson.CDhuman":"CD אדם (m)",
      "johnson.CDveh":"CD רכב (m)",
      "johnson.formulaLbl":"הערה",
      "johnson.formulaVal":"נוסחה: GSDmax = CD / (2·N)",
      "johnson.lpHint":"אם תרצה לעבוד ב-line-pairs במקום cycles: ניתן להמיר, אך כאן נשמרת עקביות עם המודל הפשוט (cycles על הממד הקריטי).",
      "johnson.line":"GSD נבחר={gsd} m/px | Slant Range={slant} m",
      "johnson.task.det":"גילוי",
      "johnson.task.rec":"הכרה",
      "johnson.task.id":"זיהוי",
      "johnson.target.human":"אדם",
      "johnson.target.veh":"רכב",

      "viz.ground":"קרקע (Z=0)",
      "viz.cam":"מצלמה (גובה {h}m)",
      "viz.title":"תרשים צד (X-Z)",
      "viz.meta":"זווית הסתכלות: {look}° | HFOV={hf}° VFOV={vf}°",
      "viz.widthNote":"רוחב קרוב≈{near}m, רוחב רחוק≈{far}m",
      "viz.scale":"סקייל דיאגרמה: xMax≈{xmax}m"
    },
    en: {
      "lang.label":"Language",
      "app.title":"GSD Calculator (Ground Sample Distance)",
      "app.subtitleA":"Pinhole model, flat ground plane.",
      "app.subtitleB":"Look angle:",
      "app.subtitleC":"0° = horizon",
      "app.subtitleD":"-90° = down",
      "app.badge":"GitHub Pages Ready",

      "inputs.title":"Inputs",
      "status.loading":"Loading…",
      "status.ok":"Computed",
      "status.warnCorner":"Note: one of the frame corners does not intersect the ground (near-horizon angle / wide FOV).",
      "status.geomError":"Geometry error: angle is too close to the horizon or rays do not intersect the ground.",

      "inputs.pxW":"Horizontal resolution (px)",
      "inputs.pxH":"Vertical resolution (px)",
      "inputs.alt":"Altitude above ground (m)",
      "inputs.look":"Look angle (deg) — 0 horizon, -90 down",
      "inputs.method":"FOV / optics input method",
      "inputs.modeFovBtn":"HFOV/VFOV (degrees)",
      "inputs.modeFocalBtn":"Sensor + focal length (mm)",
      "inputs.hfov":"HFOV (degrees)",
      "inputs.vfov":"VFOV (degrees)",
      "inputs.fovNote":"If you only have HFOV, you can estimate VFOV from the aspect ratio (or enter it manually).",
      "inputs.sensorW":"Sensor width (mm)",
      "inputs.sensorH":"Sensor height (mm)",
      "inputs.focal":"Focal length (mm)",
      "inputs.autoNoteLbl":"Note",
      "inputs.autoNoteVal":"HFOV/VFOV will be computed automatically from these values",
      "inputs.focalFormulaPrefix":"Formula:",
      "inputs.assumptions":"Assumptions: flat ground, camera axis has no roll, “Forward” is the viewing direction. For oblique angles GSD is non-uniform, so a near/far range is also shown.",

      "outputs.title":"Results",
      "outputs.slant":"Slant Range (center ray)",
      "outputs.forward":"Forward distance (center ray ground hit)",
      "outputs.area":"Footprint Area (4-corner polygon)",
      "outputs.width":"Footprint Width (left-right)",
      "outputs.nearToFar":"m (near→far)",
      "outputs.depth":"Footprint Depth (forward)",
      "outputs.gsdx":"GSD X (across-track)",
      "outputs.range":"Range:",
      "outputs.farToNear":"(far→near)",
      "outputs.gsdy":"GSD Y (along-track)",
      "outputs.gsdyNote":"Approx. (oblique projection causes variation along the frame)",
      "outputs.calcNote":"Computation notes: polygon points are the intersection of the four corner rays with the ground plane. Across-track GSD is computed per row (top row = far, bottom row = near) as ground width divided by pixel width.",
      "outputs.noIntersect":"No valid ray/ground intersection for the current parameters.",

      "johnson.title":"Johnson Criterion (DRI) — fit vs. GSD",
      "johnson.gsdSelectLbl":"Select which GSD to use for the Johnson table",
      "johnson.opt.xavg":"GSD X avg (recommended default)",
      "johnson.opt.xfar":"GSD X far (top row = far)",
      "johnson.opt.xnear":"GSD X near (bottom row = near)",
      "johnson.opt.yavg":"GSD Y avg (approx.)",
      "johnson.hintA":"The table assumes linear scaling: Rmax = Rnow · (GSDmax/GSDnow). Here Rnow is the center-ray slant range.",
      "johnson.thrLbl":"Pass threshold",
      "johnson.hintB":"At 90% probability we use N90 = N50 · K (editable below).",
      "johnson.th.rmax":"Max range (m)",
      "johnson.th.status":"Status",
      "johnson.th.gsdmax":"GSDmax (m/px)",
      "johnson.th.gsdnow":"Current GSD (m/px)",
      "johnson.th.nreq":"Required N",
      "johnson.th.prob":"Probability",
      "johnson.th.task":"Task",
      "johnson.th.target":"Target",
      "johnson.th.cd":"CD (m)",
      "johnson.detailsTitle":"Johnson settings — edit",
      "johnson.defaults":"Default values: N50 = {Detect:1.0, Recognize:4.0, Identify:6.4}, 90% factor: 1.75, CD: human 0.75m, vehicle 2.3m. Adjust to your doctrine/requirements.",
      "johnson.N50det":"N50 Detect (cycles)",
      "johnson.N50rec":"N50 Recognize (cycles)",
      "johnson.N50id":"N50 Identify (cycles)",
      "johnson.K90":"90% factor (K)",
      "johnson.CDhuman":"CD Human (m)",
      "johnson.CDveh":"CD Vehicle (m)",
      "johnson.formulaLbl":"Note",
      "johnson.formulaVal":"Formula: GSDmax = CD / (2·N)",
      "johnson.lpHint":"If you prefer line-pairs instead of cycles, you can convert; this page keeps the simple model consistent (cycles over the critical dimension).",
      "johnson.line":"Selected GSD={gsd} m/px | Slant Range={slant} m",
      "johnson.task.det":"Detect",
      "johnson.task.rec":"Recognize",
      "johnson.task.id":"Identify",
      "johnson.target.human":"Human",
      "johnson.target.veh":"Vehicle",

      "viz.ground":"Ground (Z=0)",
      "viz.cam":"Camera (height {h}m)",
      "viz.title":"Side view (X-Z)",
      "viz.meta":"Look angle: {look}° | HFOV={hf}° VFOV={vf}°",
      "viz.widthNote":"Near width≈{near}m, Far width≈{far}m",
      "viz.scale":"Diagram scale: xMax≈{xmax}m"
    }
  };

  let LANG = (localStorage.getItem("gsd_lang") || "he");
  function tr(key, vars){
    const table = I18N[LANG] || I18N.he;
    let s = table[key] ?? I18N.he[key] ?? key;
    if(vars){
      for(const k in vars){
        s = s.replaceAll("{"+k+"}", vars[k]);
      }
    }
    return s;
  }

  function applyI18n(){
    document.documentElement.lang = LANG;
    document.documentElement.dir = (LANG === "he") ? "rtl" : "ltr";
    // Buttons active state
    document.getElementById("langHe").classList.toggle("active", LANG==="he");
    document.getElementById("langEn").classList.toggle("active", LANG==="en");

    // Title tag
    document.title = tr("app.title");

    // Text nodes
    document.querySelectorAll("[data-i18n]").forEach(el=>{
      const key = el.getAttribute("data-i18n");
      el.textContent = tr(key);
    });

    // Disabled value translations
    document.querySelectorAll("[data-i18n-value]").forEach(el=>{
      const key = el.getAttribute("data-i18n-value");
      el.value = tr(key);
    });
  }

  document.getElementById("langHe").addEventListener("click", ()=>{ LANG="he"; localStorage.setItem("gsd_lang", LANG); applyI18n(); compute(); renderJohnson(); });
  document.getElementById("langEn").addEventListener("click", ()=>{ LANG="en"; localStorage.setItem("gsd_lang", LANG); applyI18n(); compute(); renderJohnson(); });

  // -----------------------------
  // Helpers
  // -----------------------------
  const $ = (id)=>document.getElementById(id);
  const rad = (deg)=>deg*Math.PI/180;
  const deg = (rad)=>rad*180/Math.PI;

  function clamp(x, a, b){ return Math.max(a, Math.min(b, x)); }
  function fmt(x, digits=3){
    if(!isFinite(x)) return "—";
    const abs = Math.abs(x);
    if(abs >= 1000) return x.toFixed(1);
    if(abs >= 100) return x.toFixed(2);
    if(abs >= 10) return x.toFixed(3);
    return x.toFixed(digits);
  }
  function polygonArea(pts){
    let a=0;
    for(let i=0;i<pts.length;i++){
      const j=(i+1)%pts.length;
      a += pts[i].x*pts[j].y - pts[j].x*pts[i].y;
    }
    return Math.abs(a)/2;
  }
  function dist2(a,b){
    const dx=a.x-b.x, dy=a.y-b.y;
    return Math.hypot(dx,dy);
  }

  // Rotate vector around Y axis by beta (rad). Coordinates:
  // X forward, Y right, Z up.
  function rotY(v, beta){
    const c=Math.cos(beta), s=Math.sin(beta);
    return { x: v.x*c + v.z*s, y: v.y, z: -v.x*s + v.z*c };
  }

  // Intersect ray from camera (0,0,H) with ground plane Z=0.
  function intersectGround(H, dir){
    const dz = dir.z;
    if(Math.abs(dz) < 1e-9) return null;
    const t = (0 - H) / dz;
    if(t <= 0) return null;
    return { x: dir.x*t, y: dir.y*t };
  }

  function cornerRaysFromFov(hfov, vfov){
    const th = Math.tan(hfov/2);
    const tv = Math.tan(vfov/2);
    return [
      {x:1, y:-th, z: +tv}, // TL
      {x:1, y:+th, z: +tv}, // TR
      {x:1, y:+th, z: -tv}, // BR
      {x:1, y:-th, z: -tv}, // BL
    ];
  }

  function normalize(v){
    const n = Math.hypot(v.x,v.y,v.z);
    return {x:v.x/n, y:v.y/n, z:v.z/n};
  }

  // -----------------------------
  // UI mode switching
  // -----------------------------
  let mode = "fov"; // "fov" | "focal"
  const btnFov = $("btnFov");
  const btnFocal = $("btnFocal");
  const modeFov = $("modeFov");
  const modeFocal = $("modeFocal");

  function setMode(m){
    mode = m;
    btnFov.classList.toggle("active", mode==="fov");
    btnFocal.classList.toggle("active", mode==="focal");
    modeFov.style.display = (mode==="fov") ? "" : "none";
    modeFocal.style.display = (mode==="focal") ? "" : "none";
    compute();
  }

  btnFov.addEventListener("click", ()=>setMode("fov"));
  btnFocal.addEventListener("click", ()=>setMode("focal"));

  // -----------------------------
  // Johnson model state
  // -----------------------------
  const johnson = {
    currentSlant: NaN,
    gsd: { x_avg: NaN, x_far: NaN, x_near: NaN, y_avg: NaN }
  };

  function getJohnsonParams(){
    const N50_det = Math.max(0.1, parseFloat($("N50_det").value||"1"));
    const N50_rec = Math.max(0.1, parseFloat($("N50_rec").value||"4"));
    const N50_id  = Math.max(0.1, parseFloat($("N50_id").value||"6.4"));
    const K90     = Math.max(1.0, parseFloat($("K90").value||"1.75"));
    const CD_h    = Math.max(0.1, parseFloat($("CD_human").value||"0.75"));
    const CD_v    = Math.max(0.1, parseFloat($("CD_vehicle").value||"2.3"));
    return { N50_det, N50_rec, N50_id, K90, CD_h, CD_v };
  }

  function buildJohnsonRows(){
    const { N50_det, N50_rec, N50_id, K90, CD_h, CD_v } = getJohnsonParams();
    const prob = $("probMode").value; // "50" or "90"
    const is90 = (prob === "90");
    const k = is90 ? K90 : 1.0;
    const probLabel = is90 ? "90%" : "50%";

    const tasks = [
      { key:"det", labelKey:"johnson.task.det",  N50:N50_det },
      { key:"rec", labelKey:"johnson.task.rec",  N50:N50_rec },
      { key:"id",  labelKey:"johnson.task.id",   N50:N50_id  },
    ];
    const targets = [
      { key:"human", labelKey:"johnson.target.human", CD:CD_h },
      { key:"veh",   labelKey:"johnson.target.veh",   CD:CD_v },
    ];

    const gsdKey = $("gsdSource").value; // x_avg / x_far / x_near / y_avg
    const gsdNow = johnson.gsd[gsdKey];
    const Rnow = johnson.currentSlant;

    const out = [];
    for(const t of targets){
      for(const task of tasks){
        const Nreq = task.N50 * k;
        const GSDmax = t.CD / (2 * Nreq); // m/px
        const pass = isFinite(gsdNow) ? (gsdNow <= GSDmax) : false;

        const Rmax = (isFinite(Rnow) && isFinite(gsdNow) && gsdNow>0)
          ? (Rnow * (GSDmax / gsdNow))
          : NaN;

        out.push({
          targetKey: t.labelKey,
          taskKey: task.labelKey,
          cd: t.CD,
          prob: probLabel,
          nreq: Nreq,
          gsdNow,
          gsdMax: GSDmax,
          rmax: Rmax,
          pass
        });
      }
    }
    return out;
  }

  function renderJohnson(){
    const body = $("johnsonBody");
    if(!body) return;
    body.innerHTML = "";

    const rows = buildJohnsonRows();

    // headline
    const gsdKey = $("gsdSource").value;
    const gsdNow = johnson.gsd[gsdKey];
    const Rnow = johnson.currentSlant;
    $("johnsonLine").textContent = tr("johnson.line", { gsd: fmt(gsdNow,6), slant: fmt(Rnow,3) });

    for(const r of rows){
      const trEl = document.createElement("tr");
      trEl.className = r.pass ? "j-pass" : "j-fail";

      const statusPill = r.pass
        ? `<span class="pill pass">PASS</span>`
        : `<span class="pill fail">FAIL</span>`;

      trEl.innerHTML = `
        <td class="mono">${fmt(r.rmax,3)}</td>
        <td>${statusPill}</td>
        <td class="mono">${fmt(r.gsdMax,6)}</td>
        <td class="mono">${fmt(r.gsdNow,6)}</td>
        <td class="mono">${fmt(r.nreq,3)}</td>
        <td>${r.prob}</td>
        <td>${tr(r.taskKey)}</td>
        <td>${tr(r.targetKey)}</td>
        <td class="mono">${fmt(r.cd,3)}</td>
      `;
      body.appendChild(trEl);
    }
  }

  // -----------------------------
  // Main compute
  // -----------------------------
  function compute(){
    const pxW = Math.max(1, parseInt($("pxW").value||"1",10));
    const pxH = Math.max(1, parseInt($("pxH").value||"1",10));
    const H = Math.max(0.01, parseFloat($("altM").value||"0.01"));

    const lookDeg = clamp(parseFloat($("lookDeg").value||"-90"), -90, 0);
    const pitchDownDeg = -lookDeg;
    const beta = rad(pitchDownDeg);

    let hfovDeg, vfovDeg;

    if(mode==="fov"){
      hfovDeg = clamp(parseFloat($("hfovDeg").value||"60"), 1, 179);
      vfovDeg = clamp(parseFloat($("vfovDeg").value||"35"), 1, 179);
    }else{
      const sensorW = Math.max(0.01, parseFloat($("sensorWmm").value||"1"));
      const sensorH = Math.max(0.01, parseFloat($("sensorHmm").value||"1"));
      const focal = Math.max(0.01, parseFloat($("focalMm").value||"1"));

      const hfov = 2*Math.atan(sensorW/(2*focal));
      const vfov = 2*Math.atan(sensorH/(2*focal));
      hfovDeg = deg(hfov);
      vfovDeg = deg(vfov);
    }

    const hfov = rad(hfovDeg);
    const vfov = rad(vfovDeg);

    const status = $("statusLine");
    const fovEcho = $("fovEcho");
    fovEcho.textContent = `HFOV=${fmt(hfovDeg,2)}° , VFOV=${fmt(vfovDeg,2)}°`;

    // Center ray
    const centerCam = {x:1, y:0, z:0};
    const centerWorld = rotY(centerCam, beta);
    const centerHit = intersectGround(H, centerWorld);

    const centerWorldN = normalize(centerWorld);
    const centerHitN = intersectGround(H, centerWorldN);
    let slant = NaN;
    if(centerHitN){
      slant = (-H) / centerWorldN.z;
    }

    if(!centerHit || !isFinite(slant) || slant<=0){
      status.textContent = tr("status.geomError");
      status.className = "small bad";
      renderEmpty();
      johnson.currentSlant = NaN;
      johnson.gsd.x_avg = NaN; johnson.gsd.x_far = NaN; johnson.gsd.x_near = NaN; johnson.gsd.y_avg = NaN;
      renderJohnson();
      return;
    }else{
      status.textContent = tr("status.ok");
      status.className = "small ok";
    }

    // Corner intersections (4 corners)
    const raysCam = cornerRaysFromFov(hfov, vfov);
    const hits = [];
    for(const rc of raysCam){
      const rw = rotY(rc, beta);
      const rwn = normalize(rw);
      const hit = intersectGround(H, rwn);
      if(!hit){
        status.textContent = tr("status.warnCorner");
        status.className = "small warn";
        break;
      }
      hits.push(hit);
    }

    let area = NaN, depth = NaN, wNear = NaN, wFar = NaN;

    if(hits.length === 4){
      const TL=hits[0], TR=hits[1], BR=hits[2], BL=hits[3];

      area = polygonArea([TL,TR,BR,BL]);

      const farMid = {x:(TL.x+TR.x)/2, y:(TL.y+TR.y)/2};
      const nearMid = {x:(BL.x+BR.x)/2, y:(BL.y+BR.y)/2};
      depth = Math.hypot(farMid.x-nearMid.x, farMid.y-nearMid.y);

      wFar = dist2(TL,TR);
      wNear = dist2(BL,BR);
    }

    // GSD calculations
    const gsdX_far = (isFinite(wFar) ? (wFar/pxW) : NaN);
    const gsdX_near = (isFinite(wNear) ? (wNear/pxW) : NaN);
    const gsdX_avg = (isFinite(wFar) && isFinite(wNear)) ? ((wFar+wNear)/2/pxW) : NaN;

    const gsdY_avg = isFinite(depth) ? (depth/pxH) : NaN;

    // Populate outputs
    $("slant").textContent = fmt(slant,3);
    $("centerX").textContent = fmt(centerHit.x,3);
    $("area").textContent = fmt(area,3);

    if(isFinite(wNear) && isFinite(wFar)){
      $("wNearFar").textContent = `${fmt(wNear,3)} → ${fmt(wFar,3)}`;
    }else{
      $("wNearFar").textContent = "—";
    }

    $("depth").textContent = fmt(depth,3);

    $("gsdXavg").textContent = fmt(gsdX_avg,6);
    $("gsdXavgCm").textContent = isFinite(gsdX_avg) ? fmt(gsdX_avg*100,4) : "—";
    $("gsdXminmax").textContent = (isFinite(gsdX_far) && isFinite(gsdX_near))
      ? `${fmt(gsdX_far,6)} → ${fmt(gsdX_near,6)}`
      : "—";

    $("gsdYavg").textContent = fmt(gsdY_avg,6);
    $("gsdYavgCm").textContent = isFinite(gsdY_avg) ? fmt(gsdY_avg*100,4) : "—";

    // Store for Johnson
    johnson.currentSlant = slant;
    johnson.gsd.x_avg = gsdX_avg;
    johnson.gsd.x_far = gsdX_far;
    johnson.gsd.x_near = gsdX_near;
    johnson.gsd.y_avg = gsdY_avg;

    // Render visualization
    renderViz({H, lookDeg, pitchDownDeg, hfovDeg, vfovDeg, centerHit, hits});

    // Render Johnson
    renderJohnson();
  }

  function renderEmpty(){
    for(const id of ["slant","centerX","area","wNearFar","depth","gsdXavg","gsdXavgCm","gsdXminmax","gsdYavg","gsdYavgCm"]){
      $(id).textContent="—";
    }
    const svg = $("viz");
    svg.innerHTML = `<rect x="0" y="0" width="920" height="420" fill="rgba(255,255,255,.02)"></rect>
      <text x="460" y="210" text-anchor="middle" fill="rgba(238,242,255,.75)" font-size="14">
        ${tr("outputs.noIntersect")}
      </text>`;
  }

  function renderViz(ctx){
    const svg = $("viz");
    const W=920, Hs=420;

    const groundY = 360;
    const camX = 110;
    const camZpx = 90;

    let xMax = Math.max(ctx.centerHit.x, 1);
    if(ctx.hits && ctx.hits.length===4){
      for(const p of ctx.hits) xMax = Math.max(xMax, p.x);
    }
    xMax *= 1.15;

    const x2px = (x)=> camX + (x/xMax) * (W-180);
    const z2px = (z)=> groundY - (z/ctx.H) * (groundY-camZpx);

    const beta = rad(-ctx.lookDeg);
    const vfov = rad(ctx.vfovDeg);
    const tv = Math.tan(vfov/2);

    const topCam = normalize({x:1,y:0,z:+tv});
    const botCam = normalize({x:1,y:0,z:-tv});
    const centerCam = normalize({x:1,y:0,z:0});

    function rotY2(v, beta){
      const c=Math.cos(beta), s=Math.sin(beta);
      return { x: v.x*c + v.z*s, y:v.y, z: -v.x*s + v.z*c };
    }
    function intersectGroundLocal(H, dir){
      if(Math.abs(dir.z)<1e-9) return null;
      const t = (0 - H)/dir.z;
      if(t<=0) return null;
      return { x: dir.x*t, z: 0 };
    }

    const cW = rotY2(centerCam, beta);
    const tW = rotY2(topCam, beta);
    const bW = rotY2(botCam, beta);

    const cHit = intersectGroundLocal(ctx.H, cW);
    const tHit = intersectGroundLocal(ctx.H, tW);
    const bHit = intersectGroundLocal(ctx.H, bW);

    const camPt = {x:0,z:ctx.H};

    let widthNote = "";
    if(ctx.hits && ctx.hits.length===4){
      const TL=ctx.hits[0], TR=ctx.hits[1], BR=ctx.hits[2], BL=ctx.hits[3];
      const wFar = Math.hypot(TL.x-TR.x, TL.y-TR.y);
      const wNear = Math.hypot(BL.x-BR.x, BL.y-BR.y);
      widthNote = tr("viz.widthNote", { near: fmt(wNear,2), far: fmt(wFar,2) });
    }

    svg.innerHTML = `
      <rect x="0" y="0" width="${W}" height="${Hs}" fill="rgba(255,255,255,.02)"></rect>

      <line x1="50" y1="${groundY}" x2="${W-40}" y2="${groundY}" stroke="rgba(255,255,255,.18)" stroke-width="2" />
      <text x="${W-45}" y="${groundY-10}" text-anchor="end" fill="rgba(168,179,214,.85)" font-size="12">${tr("viz.ground")}</text>

      <circle cx="${x2px(camPt.x)}" cy="${z2px(camPt.z)}" r="6" fill="rgba(238,242,255,.9)"></circle>
      <text x="${x2px(camPt.x)+10}" y="${z2px(camPt.z)-10}" fill="rgba(238,242,255,.85)" font-size="12">
        ${tr("viz.cam", { h: fmt(ctx.H,2) })}
      </text>

      ${cHit ? `<line x1="${x2px(camPt.x)}" y1="${z2px(camPt.z)}" x2="${x2px(cHit.x)}" y2="${groundY}"
        stroke="rgba(51,209,122,.9)" stroke-width="2"/>` : ""}

      ${tHit ? `<line x1="${x2px(camPt.x)}" y1="${z2px(camPt.z)}" x2="${x2px(tHit.x)}" y2="${groundY}"
        stroke="rgba(255,255,255,.35)" stroke-width="2"/>` : ""}

      ${bHit ? `<line x1="${x2px(camPt.x)}" y1="${z2px(camPt.z)}" x2="${x2px(bHit.x)}" y2="${groundY}"
        stroke="rgba(255,255,255,.35)" stroke-width="2"/>` : ""}

      ${cHit ? `<circle cx="${x2px(cHit.x)}" cy="${groundY}" r="5" fill="rgba(51,209,122,.95)"></circle>` : ""}

      <text x="60" y="40" fill="rgba(238,242,255,.85)" font-size="14" font-weight="650">${tr("viz.title")}</text>
      <text x="60" y="64" fill="rgba(168,179,214,.85)" font-size="12">
        ${tr("viz.meta", { look: fmt(ctx.lookDeg,2), hf: fmt(ctx.hfovDeg,2), vf: fmt(ctx.vfovDeg,2) })}
      </text>
      <text x="60" y="86" fill="rgba(168,179,214,.85)" font-size="12">
        ${widthNote}
      </text>

      <text x="${W-45}" y="40" text-anchor="end" fill="rgba(168,179,214,.75)" font-size="12">
        ${tr("viz.scale", { xmax: fmt(xMax,1) })}
      </text>
    `;
  }

  // Hook up live updates
  const inputs = [
    "pxW","pxH","altM","lookDeg","hfovDeg","vfovDeg","sensorWmm","sensorHmm","focalMm",
    "gsdSource","probMode",
    "N50_det","N50_rec","N50_id","K90","CD_human","CD_vehicle"
  ];
  inputs.forEach(id=>{
    const el = $(id);
    if(!el) return;
    el.addEventListener("input", compute);
    el.addEventListener("change", compute);
  });

  // init
  applyI18n();
  compute();
})();
</script>
</body>
</html>
