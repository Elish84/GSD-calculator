<!doctype html>
<html lang="he" dir="rtl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>מחשבון GSD (Ground Sample Distance)</title>
  <style>
    :root{
      --bg:#0b1020; --card:#121a33; --muted:#a8b3d6; --text:#eef2ff;
      --line:rgba(255,255,255,.12);
      --good:#33d17a; --warn:#ffb020; --bad:#ff4d4d;
      --radius:16px;
    }
    *{ box-sizing:border-box; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    body{ margin:0; background:linear-gradient(180deg,#070a14,#0b1020 45%,#070a14); color:var(--text); }
    header{
      position:sticky; top:0; z-index:50; backdrop-filter: blur(10px);
      background:rgba(11,16,32,.65); border-bottom:1px solid var(--line);
    }
    .wrap{ max-width:1100px; margin:0 auto; padding:16px; }
    h1{ margin:0; font-size:20px; letter-spacing:.2px; }
    .sub{ margin-top:6px; color:var(--muted); font-size:13px; }
    .grid{
      display:grid; gap:12px; margin-top:14px;
      grid-template-columns: 1.1fr .9fr;
    }
    @media (max-width: 980px){ .grid{ grid-template-columns:1fr; } }
    .card{
      background:rgba(18,26,51,.72);
      border:1px solid var(--line);
      border-radius:var(--radius);
      box-shadow: 0 10px 25px rgba(0,0,0,.25);
      overflow:hidden;
    }
    .card .hd{
      padding:14px 14px 10px;
      border-bottom:1px solid var(--line);
      display:flex; justify-content:space-between; align-items:flex-start; gap:10px;
    }
    .card .hd .t{ font-weight:700; }
    .card .bd{ padding:14px; }
    .row{ display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
    @media (max-width: 520px){ .row{ grid-template-columns:1fr; } }
    label{ display:block; font-size:12px; color:var(--muted); margin-bottom:6px; }
    input, select{
      width:100%; padding:10px 10px;
      border-radius:12px;
      border:1px solid var(--line);
      background:rgba(255,255,255,.06);
      color:var(--text);
      outline:none;
    }
    input:focus, select:focus{ border-color: rgba(168,179,214,.45); box-shadow: 0 0 0 3px rgba(168,179,214,.15); }
    .seg{
      display:flex; gap:8px; flex-wrap:wrap;
      background:rgba(255,255,255,.05);
      border:1px solid var(--line);
      padding:8px; border-radius:14px;
    }
    .seg button{
      flex:1; min-width:160px;
      border:1px solid transparent;
      border-radius:12px;
      padding:9px 10px;
      background:rgba(255,255,255,.06);
      color:var(--text);
      cursor:pointer;
    }
    .seg button.active{
      background:rgba(51,209,122,.14);
      border-color: rgba(51,209,122,.35);
    }
    .note{
      margin-top:10px; color:var(--muted); font-size:12px; line-height:1.45;
    }
    table{
      width:100%; border-collapse: collapse; overflow:hidden;
      border-radius:12px; border:1px solid var(--line);
    }
    th, td{
      padding:10px 10px;
      border-bottom:1px solid var(--line);
      font-size:13px;
    }
    th{ text-align:right; color:var(--muted); background:rgba(255,255,255,.04); font-weight:650; }
    tr:last-child td{ border-bottom:none; }
    .badge{
      display:inline-block; padding:2px 8px; border-radius:999px;
      border:1px solid var(--line); font-size:12px; color:var(--muted);
      background:rgba(255,255,255,.04);
      margin-inline-start:8px;
    }
    .ok{ color: var(--good); }
    .warn{ color: var(--warn); }
    .bad{ color: var(--bad); }
    .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }
    .svgBox{
      border:1px solid var(--line);
      background:rgba(255,255,255,.03);
      border-radius:12px;
      overflow:hidden;
    }
    .foot{
      margin-top:12px; padding-top:10px; border-top:1px solid var(--line);
      color:var(--muted); font-size:12px; line-height:1.45;
    }
    .small{ font-size:12px; color:var(--muted); }
  </style>
</head>
<body>
<header>
  <div class="wrap">
    <h1>מחשבון GSD (Ground Sample Distance)</h1>
    <div class="sub">
      מודל פין-הול, קרקע מישורית. זווית הסתכלות: <span class="mono">0° = אופק</span>, <span class="mono">-90° = למטה</span>.
      <span class="badge">GitHub Pages Ready</span>
    </div>
  </div>
</header>

<main class="wrap">
  <div class="grid">
    <!-- Inputs -->
    <section class="card">
      <div class="hd">
        <div class="t">קלטים</div>
        <div class="small" id="statusLine">טוען…</div>
      </div>
      <div class="bd">
        <div class="row">
          <div>
            <label>רזולוציה אופקית (px)</label>
            <input id="pxW" type="number" min="1" step="1" value="3840" />
          </div>
          <div>
            <label>רזולוציה אנכית (px)</label>
            <input id="pxH" type="number" min="1" step="1" value="2160" />
          </div>
        </div>

        <div class="row" style="margin-top:10px;">
          <div>
            <label>גובה מעל הקרקע (m)</label>
            <input id="altM" type="number" min="0.1" step="0.1" value="120" />
          </div>
          <div>
            <label>זווית הסתכלות (deg) — 0 אופק, -90 למטה</label>
            <input id="lookDeg" type="number" min="-90" max="0" step="0.1" value="-90" />
          </div>
        </div>

        <div style="margin-top:12px;">
          <label>שיטת הזנת שדה ראייה / אופטיקה</label>
          <div class="seg">
            <button id="btnFov" class="active" type="button">HFOV/VFOV (מעלות)</button>
            <button id="btnFocal" type="button">חיישן + אורך מוקד (mm)</button>
          </div>
        </div>

        <!-- FOV mode -->
        <div id="modeFov" style="margin-top:12px;">
          <div class="row">
            <div>
              <label>HFOV (מעלות)</label>
              <input id="hfovDeg" type="number" min="1" max="179" step="0.1" value="60" />
            </div>
            <div>
              <label>VFOV (מעלות)</label>
              <input id="vfovDeg" type="number" min="1" max="179" step="0.1" value="35" />
            </div>
          </div>
          <div class="note">
            אם יש לך רק HFOV, תוכל להעריך VFOV לפי יחס הרזולוציה (או להזין ידנית).
          </div>
        </div>

        <!-- Focal mode -->
        <div id="modeFocal" style="margin-top:12px; display:none;">
          <div class="row">
            <div>
              <label>רוחב חיישן (mm)</label>
              <input id="sensorWmm" type="number" min="0.1" step="0.01" value="6.4" />
            </div>
            <div>
              <label>גובה חיישן (mm)</label>
              <input id="sensorHmm" type="number" min="0.1" step="0.01" value="4.8" />
            </div>
          </div>
          <div class="row" style="margin-top:10px;">
            <div>
              <label>אורך מוקד (mm)</label>
              <input id="focalMm" type="number" min="0.1" step="0.01" value="8.0" />
            </div>
            <div>
              <label>הערה</label>
              <input disabled value="HFOV/VFOV יחושבו אוטומטית מהנתונים" />
            </div>
          </div>
          <div class="note">
            חישוב: <span class="mono">FOV = 2·atan(sensor/(2·focal))</span>.
          </div>
        </div>

        <div class="foot">
          הנחות: קרקע מישורית, ציר המצלמה ללא Roll, “Forward” הוא כיוון התצפית. בזוויות אלכסוניות ה-GSD אינו אחיד, לכן מוצג גם טווח (קרוב/רחוק).
        </div>
      </div>
    </section>

    <!-- Outputs -->
    <section class="card">
      <div class="hd">
        <div class="t">תוצאות</div>
        <div class="small" id="fovEcho">—</div>
      </div>
      <div class="bd">
        <table>
          <tbody>
            <tr>
              <th>Slant Range (לציר המרכזי)</th>
              <td><span id="slant" class="mono">—</span> <span class="small">m</span></td>
            </tr>
            <tr>
              <th>Forward distance (פגיעה של הציר המרכזי)</th>
              <td><span id="centerX" class="mono">—</span> <span class="small">m</span></td>
            </tr>
            <tr>
              <th>Footprint Area (פוליגון 4 פינות)</th>
              <td><span id="area" class="mono">—</span> <span class="small">m²</span></td>
            </tr>
            <tr>
              <th>Footprint Width (שמאל-ימין)</th>
              <td><span id="wNearFar" class="mono">—</span> <span class="small">m (קרוב→רחוק)</span></td>
            </tr>
            <tr>
              <th>Footprint Depth (קדימה)</th>
              <td><span id="depth" class="mono">—</span> <span class="small">m</span></td>
            </tr>
            <tr>
              <th>GSD X (רוחבי)</th>
              <td>
                <div><span id="gsdXavg" class="mono">—</span> <span class="small">m/px</span> (<span id="gsdXavgCm" class="mono">—</span> <span class="small">cm/px</span>)</div>
                <div class="small">טווח: <span id="gsdXminmax" class="mono">—</span> m/px (רחוק→קרוב)</div>
              </td>
            </tr>
            <tr>
              <th>GSD Y (אורכי)</th>
              <td>
                <div><span id="gsdYavg" class="mono">—</span> <span class="small">m/px</span> (<span id="gsdYavgCm" class="mono">—</span> <span class="small">cm/px</span>)</div>
                <div class="small">בקירוב (הקרנה אלכסונית גורמת לשונות לאורך הפריים)</div>
              </td>
            </tr>
          </tbody>
        </table>

        <div style="height:12px;"></div>
        <div class="svgBox">
          <svg id="viz" viewBox="0 0 920 420" width="100%" height="auto" aria-label="תרשים גיאומטריה">
            <!-- Filled by JS -->
          </svg>
        </div>

        <div class="note">
          לצרכי חישוב: נקודות הפוליגון מתקבלות מחיתוך הקרניים (פינות הפריים) עם מישור הקרקע.
          ה-GSD הרוחבי מחושב לכל אחת מהשורות (העליונה=רחוק, התחתונה=קרוב) לפי רוחב בשטח חלקי פיקסלים.
        </div>
      </div>
    </section>
  </div>
</main>

<script>
(function(){
  // -----------------------------
  // Helpers
  // -----------------------------
  const $ = (id)=>document.getElementById(id);
  const rad = (deg)=>deg*Math.PI/180;
  const deg = (rad)=>rad*180/Math.PI;

  function clamp(x, a, b){ return Math.max(a, Math.min(b, x)); }
  function fmt(x, digits=3){
    if(!isFinite(x)) return "—";
    const abs = Math.abs(x);
    if(abs >= 1000) return x.toFixed(1);
    if(abs >= 100) return x.toFixed(2);
    if(abs >= 10) return x.toFixed(3);
    return x.toFixed(digits);
  }
  function polygonArea(pts){
    // pts: [{x,y},...], assumes order around polygon
    let a=0;
    for(let i=0;i<pts.length;i++){
      const j=(i+1)%pts.length;
      a += pts[i].x*pts[j].y - pts[j].x*pts[i].y;
    }
    return Math.abs(a)/2;
  }
  function dist2(a,b){
    const dx=a.x-b.x, dy=a.y-b.y;
    return Math.hypot(dx,dy);
  }

  // Rotate vector around Y axis by beta (rad). Coordinates:
  // X forward, Y right, Z up.
  function rotY(v, beta){
    const c=Math.cos(beta), s=Math.sin(beta);
    return {
      x: v.x*c + v.z*s,
      y: v.y,
      z: -v.x*s + v.z*c
    };
  }

  // Intersect ray from camera (0,0,H) with ground plane Z=0.
  // Ray: P(t)=C + t*dirWorld, dirWorld normalized-ish.
  function intersectGround(H, dir){
    const dz = dir.z;
    if(Math.abs(dz) < 1e-9) return null; // parallel to ground
    const t = (0 - H) / dz; // H + t*dz = 0
    if(t <= 0) return null; // intersection behind camera
    return { x: dir.x*t, y: dir.y*t };
  }

  // Build camera corner rays (in camera frame) from FOV
  function cornerRaysFromFov(hfov, vfov){
    const th = Math.tan(hfov/2);
    const tv = Math.tan(vfov/2);

    // Image plane at x=1. y is right, z is up.
    // Corners: TL, TR, BR, BL (order around polygon)
    const corners = [
      {x:1, y:-th, z: +tv}, // TL (left is -y)
      {x:1, y:+th, z: +tv}, // TR
      {x:1, y:+th, z: -tv}, // BR
      {x:1, y:-th, z: -tv}, // BL
    ];
    return corners;
  }

  function normalize(v){
    const n = Math.hypot(v.x,v.y,v.z);
    return {x:v.x/n, y:v.y/n, z:v.z/n};
  }

  // -----------------------------
  // UI mode switching
  // -----------------------------
  let mode = "fov"; // "fov" | "focal"
  const btnFov = $("btnFov");
  const btnFocal = $("btnFocal");
  const modeFov = $("modeFov");
  const modeFocal = $("modeFocal");

  function setMode(m){
    mode = m;
    btnFov.classList.toggle("active", mode==="fov");
    btnFocal.classList.toggle("active", mode==="focal");
    modeFov.style.display = (mode==="fov") ? "" : "none";
    modeFocal.style.display = (mode==="focal") ? "" : "none";
    compute();
  }

  btnFov.addEventListener("click", ()=>setMode("fov"));
  btnFocal.addEventListener("click", ()=>setMode("focal"));

  // -----------------------------
  // Main compute
  // -----------------------------
  function compute(){
    const pxW = Math.max(1, parseInt($("pxW").value||"1",10));
    const pxH = Math.max(1, parseInt($("pxH").value||"1",10));
    const H = Math.max(0.01, parseFloat($("altM").value||"0.01"));

    const lookDeg = clamp(parseFloat($("lookDeg").value||"-90"), -90, 0);
    // Convert: user look angle γ: 0(horizon) .. -90(nadir)
    // pitchDown β: 0..90 (positive rotates X toward -Z)
    const pitchDownDeg = -lookDeg; // e.g. -(-90)=90
    const beta = rad(pitchDownDeg);

    let hfovDeg, vfovDeg;

    if(mode==="fov"){
      hfovDeg = clamp(parseFloat($("hfovDeg").value||"60"), 1, 179);
      vfovDeg = clamp(parseFloat($("vfovDeg").value||"35"), 1, 179);
    }else{
      const sensorW = Math.max(0.01, parseFloat($("sensorWmm").value||"1"));
      const sensorH = Math.max(0.01, parseFloat($("sensorHmm").value||"1"));
      const focal = Math.max(0.01, parseFloat($("focalMm").value||"1"));

      const hfov = 2*Math.atan(sensorW/(2*focal));
      const vfov = 2*Math.atan(sensorH/(2*focal));
      hfovDeg = deg(hfov);
      vfovDeg = deg(vfov);
    }

    const hfov = rad(hfovDeg);
    const vfov = rad(vfovDeg);

    // Validate geometry
    const status = $("statusLine");
    const fovEcho = $("fovEcho");

    fovEcho.textContent = `HFOV=${fmt(hfovDeg,2)}° , VFOV=${fmt(vfovDeg,2)}°`;

    // Center ray
    const centerCam = {x:1, y:0, z:0};
    const centerWorld = rotY(centerCam, beta);
    const centerHit = intersectGround(H, centerWorld);

    // Slant range along center ray: t (since dir not normalized, compute with normalized dir)
    const centerWorldN = normalize(centerWorld);
    const centerHitN = intersectGround(H, centerWorldN);
    let slant = NaN;
    if(centerHitN){
      // t = distance from camera to hit, since direction normalized and origin at (0,0,H)
      // P = C + t*dir, z=0 => t = -H/dir.z
      slant = (-H) / centerWorldN.z;
    }

    // If looking too close to horizon, rays may not hit ground (or huge range)
    if(!centerHit || !isFinite(slant) || slant<=0){
      status.textContent = "שגיאה גיאומטרית: הזווית קרובה מדי לאופק או הקרניים לא פוגעות בקרקע.";
      status.className = "small bad";
      renderEmpty();
      return;
    }else{
      status.textContent = "מחושב";
      status.className = "small ok";
    }

    // Corner intersections (4 corners)
    const raysCam = cornerRaysFromFov(hfov, vfov);
    const hits = [];
    for(const rc of raysCam){
      const rw = rotY(rc, beta);
      const rwn = normalize(rw);
      const hit = intersectGround(H, rwn);
      if(!hit){
        // If any corner misses ground, we cannot form footprint reliably
        status.textContent = "הערה: אחת מפינות הפריים לא פוגעת בקרקע (זווית קרובה לאופק / FOV רחב).";
        status.className = "small warn";
        break;
      }
      hits.push(hit);
    }

    // Even if a corner misses, we can still show center + partial; but footprint requires all 4.
    let area = NaN, depth = NaN, wNear = NaN, wFar = NaN;

    if(hits.length === 4){
      // Define "far edge" as top row: TL-TR (z=+tv in our construction)
      // "near edge" as bottom row: BL-BR (z=-tv) => hits[3]-hits[2] depending on ordering
      const TL=hits[0], TR=hits[1], BR=hits[2], BL=hits[3];

      area = polygonArea([TL,TR,BR,BL]);

      // Forward axis is X on ground plane. Depth: difference between far and near along X at center column.
      // Approx use midpoints of far and near edges.
      const farMid = {x:(TL.x+TR.x)/2, y:(TL.y+TR.y)/2};
      const nearMid = {x:(BL.x+BR.x)/2, y:(BL.y+BR.y)/2};
      depth = Math.hypot(farMid.x-nearMid.x, farMid.y-nearMid.y);

      wFar = dist2(TL,TR);
      wNear = dist2(BL,BR);
    }

    // GSD calculations
    // X GSD varies: far row and near row widths / pxW
    const gsdX_far = (isFinite(wFar) ? (wFar/pxW) : NaN);
    const gsdX_near = (isFinite(wNear) ? (wNear/pxW) : NaN);
    const gsdX_avg = (isFinite(wFar) && isFinite(wNear)) ? ((wFar+wNear)/2/pxW) : NaN;

    // Y (vertical) GSD: use depth / pxH as an average approximation (oblique distortion not uniform)
    const gsdY_avg = isFinite(depth) ? (depth/pxH) : NaN;

    // Populate outputs
    $("slant").textContent = fmt(slant,3);
    $("centerX").textContent = fmt(centerHit.x,3);
    $("area").textContent = fmt(area,3);

    if(isFinite(wNear) && isFinite(wFar)){
      $("wNearFar").textContent = `${fmt(wNear,3)} → ${fmt(wFar,3)}`;
    }else{
      $("wNearFar").textContent = "—";
    }

    $("depth").textContent = fmt(depth,3);

    $("gsdXavg").textContent = fmt(gsdX_avg,6);
    $("gsdXavgCm").textContent = isFinite(gsdX_avg) ? fmt(gsdX_avg*100,4) : "—";
    $("gsdXminmax").textContent = (isFinite(gsdX_far) && isFinite(gsdX_near))
      ? `${fmt(gsdX_far,6)} → ${fmt(gsdX_near,6)}`
      : "—";

    $("gsdYavg").textContent = fmt(gsdY_avg,6);
    $("gsdYavgCm").textContent = isFinite(gsdY_avg) ? fmt(gsdY_avg*100,4) : "—";

    // Render visualization
    renderViz({H, lookDeg, pitchDownDeg, hfovDeg, vfovDeg, centerHit, hits});
  }

  function renderEmpty(){
    for(const id of ["slant","centerX","area","wNearFar","depth","gsdXavg","gsdXavgCm","gsdXminmax","gsdYavg","gsdYavgCm"]){
      $(id).textContent="—";
    }
    const svg = $("viz");
    svg.innerHTML = `<rect x="0" y="0" width="920" height="420" fill="rgba(255,255,255,.02)"></rect>
      <text x="460" y="210" text-anchor="middle" fill="rgba(238,242,255,.75)" font-size="14">
        אין חיתוך קרניים תקין עם הקרקע עבור הפרמטרים הנוכחיים.
      </text>`;
  }

  function renderViz(ctx){
    const svg = $("viz");
    const W=920, Hs=420;

    // Simple 2D side-view (X-Z): show camera at (0,H), ground line, center ray, and top/bottom rays (center column)
    // Scale: map x in [0..xMax] to [80..880], z in [0..H] to [360..70]
    const groundY = 360;
    const camX = 110;
    const camZpx = 90;

    // Determine xMax for scaling: use farthest of corner hits' x and center x
    let xMax = Math.max(ctx.centerHit.x, 1);
    if(ctx.hits && ctx.hits.length===4){
      for(const p of ctx.hits) xMax = Math.max(xMax, p.x);
    }
    // add margin
    xMax *= 1.15;

    const x2px = (x)=> camX + (x/xMax) * (W-180);
    const z2px = (z)=> groundY - (z/ctx.H) * (groundY-camZpx);

    // Rays in 2D for center/top/bottom at center column:
    const beta = rad(-ctx.lookDeg); // pitchDown
    const hfov = rad(ctx.hfovDeg);
    const vfov = rad(ctx.vfovDeg);
    const tv = Math.tan(vfov/2);

    // center column top/bottom rays in camera frame (x=1,y=0,z=±tv)
    const topCam = normalize({x:1,y:0,z:+tv});
    const botCam = normalize({x:1,y:0,z:-tv});
    const centerCam = normalize({x:1,y:0,z:0});

    function rotY(v, beta){
      const c=Math.cos(beta), s=Math.sin(beta);
      return { x: v.x*c + v.z*s, y:v.y, z: -v.x*s + v.z*c };
    }
    function intersectGroundLocal(H, dir){
      if(Math.abs(dir.z)<1e-9) return null;
      const t = (0 - H)/dir.z;
      if(t<=0) return null;
      return { x: dir.x*t, z: 0 };
    }

    const cW = rotY(centerCam, beta);
    const tW = rotY(topCam, beta);
    const bW = rotY(botCam, beta);

    const cHit = intersectGroundLocal(ctx.H, cW);
    const tHit = intersectGroundLocal(ctx.H, tW);
    const bHit = intersectGroundLocal(ctx.H, bW);

    const camPt = {x:0,z:ctx.H};

    // 2D footprint width note: from 3D hits show near/far widths if available
    let widthNote = "";
    if(ctx.hits && ctx.hits.length===4){
      const TL=ctx.hits[0], TR=ctx.hits[1], BR=ctx.hits[2], BL=ctx.hits[3];
      const wFar = Math.hypot(TL.x-TR.x, TL.y-TR.y);
      const wNear = Math.hypot(BL.x-BR.x, BL.y-BR.y);
      widthNote = `רוחב קרוב≈${fmt(wNear,2)}m, רוחב רחוק≈${fmt(wFar,2)}m`;
    }

    svg.innerHTML = `
      <rect x="0" y="0" width="${W}" height="${Hs}" fill="rgba(255,255,255,.02)"></rect>

      <!-- Ground -->
      <line x1="50" y1="${groundY}" x2="${W-40}" y2="${groundY}" stroke="rgba(255,255,255,.18)" stroke-width="2" />
      <text x="${W-45}" y="${groundY-10}" text-anchor="end" fill="rgba(168,179,214,.85)" font-size="12">קרקע (Z=0)</text>

      <!-- Camera -->
      <circle cx="${x2px(camPt.x)}" cy="${z2px(camPt.z)}" r="6" fill="rgba(238,242,255,.9)"></circle>
      <text x="${x2px(camPt.x)+10}" y="${z2px(camPt.z)-10}" fill="rgba(238,242,255,.85)" font-size="12">
        מצלמה (גובה ${fmt(ctx.H,2)}m)
      </text>

      <!-- Rays -->
      ${cHit ? `<line x1="${x2px(camPt.x)}" y1="${z2px(camPt.z)}" x2="${x2px(cHit.x)}" y2="${groundY}"
        stroke="rgba(51,209,122,.9)" stroke-width="2"/>` : ""}

      ${tHit ? `<line x1="${x2px(camPt.x)}" y1="${z2px(camPt.z)}" x2="${x2px(tHit.x)}" y2="${groundY}"
        stroke="rgba(255,255,255,.35)" stroke-width="2"/>` : ""}

      ${bHit ? `<line x1="${x2px(camPt.x)}" y1="${z2px(camPt.z)}" x2="${x2px(bHit.x)}" y2="${groundY}"
        stroke="rgba(255,255,255,.35)" stroke-width="2"/>` : ""}

      <!-- Center hit marker -->
      ${cHit ? `<circle cx="${x2px(cHit.x)}" cy="${groundY}" r="5" fill="rgba(51,209,122,.95)"></circle>` : ""}

      <!-- Labels -->
      <text x="60" y="40" fill="rgba(238,242,255,.85)" font-size="14" font-weight="650">תרשים צד (X-Z)</text>
      <text x="60" y="64" fill="rgba(168,179,214,.85)" font-size="12">
        זווית הסתכלות: ${fmt(ctx.lookDeg,2)}° | HFOV=${fmt(ctx.hfovDeg,2)}° VFOV=${fmt(ctx.vfovDeg,2)}°
      </text>
      <text x="60" y="86" fill="rgba(168,179,214,.85)" font-size="12">
        ${widthNote}
      </text>

      <!-- Scale note -->
      <text x="${W-45}" y="40" text-anchor="end" fill="rgba(168,179,214,.75)" font-size="12">
        סקייל דיאגרמה: xMax≈${fmt(xMax,1)}m
      </text>
    `;
  }

  // Hook up live updates
  const inputs = [
    "pxW","pxH","altM","lookDeg","hfovDeg","vfovDeg","sensorWmm","sensorHmm","focalMm"
  ];
  inputs.forEach(id=>{
    const el = $(id);
    if(!el) return;
    el.addEventListener("input", compute);
    el.addEventListener("change", compute);
  });

  // initial
  compute();
})();
</script>
</body>
</html>
